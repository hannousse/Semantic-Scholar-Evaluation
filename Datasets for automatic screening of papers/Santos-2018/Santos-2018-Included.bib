%% This BibTeX bibliography file was created using BibDesk.
%% https://bibdesk.sourceforge.io/

%% Created for Salima Yahiouche at 2020-10-24 20:35:09 +0100 


%% Saved with string encoding Unicode (UTF-8) 



@inproceedings{Codabux:2017,
	Abstract = {Context: It is important to maintain software quality as a software system evolves. Managing code smells in source code contributes towards quality software. While metrics have been used to pinpoint code smells in source code, we present an empirical study on the correlation of code smells with class-level (micro pattern) and method- level (nano-pattern) traceable patterns of code. Objective: This study explores the relationship between code smells and class-level and method-level structural code constructs. Method: We extracted micro patterns at the class level and nano-patterns at the method level from three versions of Apache Tomcat and PersonalBlog and Roller from Stand- ford SecuriBench and compared their distributions in code smell versus non-code smell classes and methods.Result: We found that DataManager, Record and Outline mi- cro patterns are more frequent in classes having code smell compared to non-code smell classes in the applications we analyzed. localReader, localW riter, Switcher, and ArrReader nano-patterns are more frequent in code smell methods compared to the non-code smell methods. Conclu- sion: We conclude that code smells are correlated with both micro and nano-patterns.
},
	Author = {Zadia Codabux and Kazi Zakia Sultana and Byron J. Williams},
	Booktitle = {The 29th International Conference on Software Engineering & Knowledge Engineering (SEKE)},
	Date-Added = {2019-05-07 01:19:07 +0100},
	Date-Modified = {2020-10-24 20:35:05 +0100},
	Doi = {10.18293/SEKE2017-121},
	Pages = {6},
	Title = {The Relationship between Traceable Code Patterns and Code Smells},
	Year = {2017},
	Bdsk-Url-1 = {https://doi.org/10.18293/SEKE2017-121}}

@article{Tufano:2017,
	Abstract = {Technical debt is a metaphor introduced by Cunningham to indicate ``not quite right code which we postpone making it right''. One noticeable symptom of technical debt is represented by code smells, defined as symptoms of poor design and implementation choices. Previous studies showed the negative impact of code smells on the comprehensibility and maintainability of code. While the repercussions of smells on code quality have been empirically assessed, there is still only anecdotal evidence on when and why bad smells are introduced, what is their survivability, and how they are removed by developers. To empirically corroborate such anecdotal evidence, we conducted a large empirical study over the change history of 200 open source projects. This study required the development of a strategy to identify smell-introducing commits, the mining of over half a million of commits, and the manual analysis and classification of over 10K of them. Our findings mostly contradict common wisdom, showing that most of the smell instances are introduced when an artifact is created and not as a result of its evolution. At the same time, 80 percent of smells survive in the system. Also, among the 20 percent of removed instances, only 9 percent are removed as a direct consequence of refactoring operations.},
	Author = {M. {Tufano} and F. {Palomba} and G. {Bavota} and R. {Oliveto} and M. D. {Penta} and A. {De Lucia} and D. {Poshyvanyk}},
	Date-Added = {2019-05-07 01:13:52 +0100},
	Date-Modified = {2020-10-22 14:34:51 +0100},
	Doi = {10.1109/TSE.2017.2653105},
	Issn = {0098-5589},
	Journal = {IEEE Transactions on Software Engineering},
	Keywords = {data mining;public domain software;software maintenance;software quality;source code (software);open source projects;code smells;code comprehensibility;code maintainability;commits mining;smell instances;smell-introducing commits;code quality;technical debt;Ecosystems;History;Androids;Humanoid robots;Software systems;Maintenance engineering;Code smells;empirical study;mining software repositories},
	Number = {11},
	Pages = {1063-1088},
	Title = {When and Why Your Code Starts to Smell Bad (and Whether the Smells Go Away)},
	Volume = {43},
	Year = {2017},
	Bdsk-Url-1 = {https://doi.org/10.1109/TSE.2017.2653105}}

@inproceedings{Ahmed:2017,
	Abstract = {Background: Merge conflicts are a common occurrence in software development. Researchers have shown the negative impact of conflicts on the resulting code quality and the development workflow. Thus far, no one has investigated the effect of bad design (code smells) on merge conflicts. Aims: We posit that entities that exhibit certain types of code smells are more likely to be involved in a merge conflict. We also postulate that code elements that are both "smelly" and involved in a merge conflict are associated with other undesirable effects (more likely to be buggy). Method: We mined 143 repositories from GitHub and recreated 6,979 merge conflicts to obtain metrics about code changes and conflicts. We categorized conflicts into semantic or non-semantic, based on whether changes affected the Abstract Syntax Tree. For each conflicting change, we calculate the number of code smells and the number of future bug-fixes associated with the affected lines of code. Results: We found that entities that are smelly are three times more likely to be involved in merge conflicts. Method-level code smells (Blob Operation and Internal Duplication) are highly correlated with semantic conflicts. We also found that code that is smelly and experiences merge conflicts is more likely to be buggy. Conclusion: Bad code design not only impacts maintainability, it also impacts the day to day operations of a project, such as merging contributions, and negatively impacts the quality of the resulting code. Our findings indicate that research is needed to identify better ways to support merge conflict resolution to minimize its effect on code quality.},
	Author = {I. {Ahmed} and C. {Brindescu} and U. A. {Mannan} and C. {Jensen} and A. {Sarma}},
	Booktitle = {2017 ACM/IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM)},
	Date-Added = {2019-05-07 01:12:56 +0100},
	Date-Modified = {2020-10-22 14:33:09 +0100},
	Doi = {10.1109/ESEM.2017.12},
	Keywords = {data mining;program debugging;public domain software;software maintenance;software metrics;conflicting change;method-level code;semantic conflicts;code changes;code elements;resulting code quality;merge conflicts Background;code smells;conflict resolution;Bad code design;Software;Merging;Computer bugs;Tools;Software measurement;Semantics;Code Smell;Merge Conflict;Empirical Analysis;Machine Learning},
	Pages = {58-67},
	Title = {An Empirical Examination of the Relationship between Code Smells and Merge Conflicts},
	Year = {2017},
	Bdsk-Url-1 = {https://doi.org/10.1109/ESEM.2017.12}}

@inproceedings{Mello:2017,
	Abstract = {Context: Code smells are symptoms in the source code that represent poor design choices. Professional developers often perceive several types of code smells as indicators of actual design problems. However, the identification of code smells involves multiple steps that are subjective in nature, requiring the engagement of humans. Human factors are likely to play a key role in the precise identification of code smells in industrial settings. Unfortunately, there is limited knowledge about the influence of human factors on smell identification. Goal: We aim at investigating whether the precision of smell identification is influenced by three key human factors, namely reviewer's professional background, reviewer's module knowledge and collaboration of reviewers during the task. We also aim at deriving recommendations for allocating human resources to smell identification tasks. Method: We performed 19 comparisons among different subsamples from two trials of a controlled experiment conducted in the context of an empirical study on code smell identification. One trial was conducted in industrial settings while the other had involved graduate students. The diversity of the samples allowed us to analyze the influence of the three factors in isolation and in conjunction. Results: We found that (i) reviewers' collaboration significantly increases the precision of smell identification, but (ii) some professional background is required from the reviewers to reach high precision. Surprisingly, we also found that: (iii) having previous knowledge of the reviewed module does not affect the precision of reviewers with higher professional background. However, this factor was influential on successful identification of more complex smells. Conclusion: We expect that our findings are helpful to support researchers in conducting proper experimental procedures in the future. Besides, they may also be useful for supporting project managers in allocating resources for smell identification tasks.},
	Author = {R. M. d. {Mello} and R. F. {Oliveira} and A. F. {Garcia}},
	Booktitle = {2017 ACM/IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM)},
	Date-Added = {2019-05-07 01:12:12 +0100},
	Date-Modified = {2020-10-22 14:34:32 +0100},
	Doi = {10.1109/ESEM.2017.13},
	Keywords = {human factors;software maintenance;software quality;code smells;multitrial empirical study;human factors;complex smells;code smell identification;smell identification tasks;human resources;Human factors;Collaboration;Tools;Software systems;Software measurement;code smell identification;human factors;context;collaboration;code review;replication},
	Pages = {68-77},
	Title = {On the Influence of Human Factors for Identifying Code Smells: A Multi-Trial Empirical Study},
	Year = {2017},
	Bdsk-Url-1 = {https://doi.org/10.1109/ESEM.2017.13}}

@inproceedings{Rani:2017,
	Abstract = {The symptoms which reflect the poor design quality of code are known as code smells. Refactoring is one of the possible ways to remove code smells, but refactoring does not come for free to developer. So there is a need to have efficient refactoring strategies. For this purpose an empirical study on distribution of different code smells over different versions of projects is provided in this paper, so that refactoring strategies can be built keeping in a view that which smell is more effective and at which time during evolution of software. For experiment, different versions of Junit, GCviewer and Gitblit have been taken. To detect the smells and violations in code JDeodorant and PMD tools are used. Study shows that a) Latest version of software has more design issues than that of oldest ones; b) God smell and urgent violations have more contribution than other smells whereas instances having Type Checking smell are very less in all the versions. Study shows that initial version of project can be used as reference architecture for purpose of reverse Engineering. We also found that Gitblit has better code design than that of other two softwares.},
	Author = {A. {Rani} and J. K. {Chhabra}},
	Booktitle = {2017 2nd International Conference for Convergence in Technology (I2CT)},
	Date-Added = {2019-05-07 01:11:18 +0100},
	Date-Modified = {2020-10-22 14:33:39 +0100},
	Doi = {10.1109/I2CT.2017.8226297},
	Keywords = {Java;program testing;reverse engineering;software maintenance;software quality;Gitblit;code JDeodorant;Type Checking smell;refactoring strategies;reverse engineering;empirical study;code design;code smells;design quality;Software;Tools;Feature extraction;Software measurement;History;System analysis and design;code smell;empirical study;refactoring;object oriented maintainence},
	Pages = {1093-1098},
	Title = {Evolution of code smells over multiple versions of softwares: An empirical investigation},
	Year = {2017},
	Bdsk-Url-1 = {https://doi.org/10.1109/I2CT.2017.8226297}}

@article{Khomh:2011,
	Abstract = {Antipatterns are poor design choices that are conjectured to make object-oriented systems harder to maintain. We investigate the impact of antipatterns on classes in object-oriented systems by studying the relation between the presence of antipatterns and the change- and fault-proneness of the classes. We detect 13 antipatterns in 54 releases of ArgoUML, Eclipse, Mylyn, and Rhino, and analyse (1) to what extent classes participating in antipatterns have higher odds to change or to be subject to fault-fixing than other classes, (2) to what extent these odds (if higher) are due to the sizes of the classes or to the presence of antipatterns, and (3) what kinds of changes affect classes participating in antipatterns. We show that, in almost all releases of the four systems, classes participating in antipatterns are more change-and fault-prone than others. We also show that size alone cannot explain the higher odds of classes with antipatterns to underwent a (fault-fixing) change than other classes. Finally, we show that structural changes affect more classes with antipatterns than others. We provide qualitative explanations of the increase of change- and fault-proneness in classes participating in antipatterns using release notes and bug reports. The obtained results justify a posteriori previous work on the specification and detection of antipatterns and could help to better focus quality assurance and testing activities.},
	Author = {Khomh, Foutse and Penta, Massimiliano Di and Gu{\'e}h{\'e}neuc, Yann-Ga{\"e}l and Antoniol, Giuliano},
	Date-Added = {2019-05-07 01:09:55 +0100},
	Date-Modified = {2020-10-22 14:24:17 +0100},
	Doi = {10.1007/s10664-011-9171-y},
	Issn = {1573-7616},
	Journal = {Empirical Software Engineering},
	Keywords = {Antipatterns; Mining software repositories; Empirical software engineering},
	Number = {3},
	Pages = {243--275},
	Publisher = {Springer Nature},
	Title = {An exploratory study of the impact of antipatterns on class change- and fault-proneness},
	Url = {http://dx.doi.org/10.1007/s10664-011-9171-y},
	Volume = {17},
	Year = {2011},
	Bdsk-Url-1 = {http://dx.doi.org/10.1007/s10664-011-9171-y}}

@article{Romano:2012,
	Abstract = {Antipatterns are poor solutions to design and implementation problems which are claimed to make object oriented systems hard to maintain. Our recent studies showed that classes with antipatterns change more frequently than classes without antipatterns. In this paper, we detail these analyses by taking into account fine-grained source code changes (SCC) extracted from 16 Java open source systems. In particular we investigate: whether classes with antipatterns are more change-prone (in terms of SCC) than classes without, (2) whether the type of antipattern impacts the change-proneness of Java classes, and (3) whether certain types of changes are performed more frequently in classes affected by a certain antipattern. Our results show that: 1) the number of SCC performed in classes affected by antipatterns is statistically greater than the number of SCC performed in classes with no antipattern, 2) classes participating in the three antipatterns Complex Class, Spaghetti Code, and SwissArmyKnife are more change-prone than classes affected by other antipatterns, and 3) certain types of changes are more likely to be performed in classes affected by certain antipatterns, such as API changes are likely to be performed in classes affected by the Complex Class, Spaghetti Code, and SwissArmyKnife antipatterns.},
	Author = {Romano, Daniele and Raila, Paulius and Pinzger, Martin and Khomh, Foutse},
	Date-Added = {2019-05-07 01:09:21 +0100},
	Date-Modified = {2020-10-24 20:26:00 +0100},
	Doi = {10.1109/wcre.2012.53},
	Isbn = {9781467345361},
	Journal = {2012 19th Working Conference on Reverse Engineering},
	Keywords = {Antipatterns; change-proneness; fine-grained source code changes; empirical software engineering},
	Pages = {437-446},
	Publisher = {IEEE},
	Title = {Analyzing the Impact of Antipatterns on Change-Proneness Using Fine-Grained Source Code Changes},
	Url = {http://dx.doi.org/10.1109/WCRE.2012.53},
	Year = {2012},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/WCRE.2012.53},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/wcre.2012.53}}

@article{Sabane:2013,
	Abstract = {Antipatterns are known as recurring, poor design choices, recent and past studies indicated that they negatively affect software systems in terms of understand ability and maintainability, also increasing change-and defect-proneness. For this reason, refactoring actions are often suggested. In this paper, we investigate a different side-effect of antipatterns, which is their effect on testability and on testing cost in particular. We consider as (upper bound) indicator of testing cost the number of test cases that satisfy the minimal data member usage matrix (MaDUM) criterion proposed by Bashir and Goel. A study-carried out on four Java programs, Ant 1.8.3, ArgoUML 0.20, Check Style 4.0, and JFreeChart 1.0.13-supports the evidence that, on the one hand, antipatterns unit testing requires, on average, a number of test cases substantially higher than unit testing for non-antipattern classes. On the other hand, antipattern classes must be carefully tested because they are more defect-prone than other classes. Finally, we illustrate how specific refactoring actions-applied to classes participating in antipatterns-could reduce testing cost.},
	Author = {Sabane, A. and Di Penta, M. and Antoniol, G. and Gueheneuc, Y.},
	Date-Added = {2019-05-07 01:08:50 +0100},
	Date-Modified = {2020-10-24 20:27:30 +0100},
	Doi = {10.1109/csmr.2013.26},
	Isbn = {9781467358330},
	Journal = {2013 17th European Conference on Software Maintenance and Reengineering},
	Keywords = {Antipatterns; Object oriented testing; Testing cost; Refactoring},
	Pages = {167-176},
	Publisher = {IEEE},
	Title = {A Study on the Relation between Antipatterns and the Cost of Class Unit Testing},
	Url = {http://dx.doi.org/10.1109/CSMR.2013.26},
	Year = {2013},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/CSMR.2013.26},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/csmr.2013.26}}

@article{Taibi:2017,
	Abstract = {Context. In recent years, smells, also referred to as bad smells, have gained popularity among developers. However, it is still not clear how harmful they are perceived from the developers' point of view. Many developers talk about them, but only few know what they really are, and even fewer really take care of them in their source code. Objective. The goal of this work is to understand the perceived criticality of code smells both in theory, when reading their description, and in practice. Method. We executed an empirical study as a differentiated external replication of two previous studies. The studies were conducted as surveys involving only highly experienced developers (63 in the first study and 41 in the second one). First the perceived criticality was analyzed by proposing the description of the smells, then different pieces of code infected by the smells were proposed, and finally their ability to identify the smells in the analyzed code was tested. Results. According to our knowledge, this is the largest study so far investigating the perception of code smells with professional software developers. The results show that developers are very concerned about code smells in theory, nearly always considering them as harmful or very harmful (17 out of 23 smells). However, when they were asked to analyze an infected piece of code, only few infected classes were considered harmful and even fewer were considered harmful because of the smell. Conclusions. The results confirm our initial hypotheses that code smells are perceived as more critical in theory but not as critical in practice.},
	Author = {Davide Taibi and Andrea Janes and Valentina Lenarduzzi},
	Date-Added = {2019-05-07 01:08:13 +0100},
	Date-Modified = {2019-08-31 18:09:44 +0100},
	Doi = {10.1016/j.infsof.2017.08.008},
	Issn = {0950-5849},
	Journal = {Information and Software Technology},
	Keywords = {Software maintenance, Code smells, Bad smells, Antipatterns, Refactoring},
	Pages = {223 - 235},
	Title = {How developers perceive smells in source code: A replicated study},
	Url = {http://www.sciencedirect.com/science/article/pii/S0950584916304128},
	Volume = {92},
	Year = {2017},
	Bdsk-Url-1 = {http://www.sciencedirect.com/science/article/pii/S0950584916304128},
	Bdsk-Url-2 = {https://doi.org/10.1016/j.infsof.2017.08.008}}

@article{Jaafar:2014,
	Abstract = {Software evolution and development are continuous activities that have a never-ending cycle. While developers commit changes on a software system to fix bugs or to implement new requirements, they sometimes introduce anti-patterns, which are bad solutions to recurring design problems in the system. Many previous studies have shown that these anti-patterns have negative effects on code quality, in particular fault-proneness. However, it is not clear if and how anti-patterns evolve and which evolutionary behaviours are more fault-prone. This paper presents results from an empirical study aimed at understanding the evolution of anti-patterns in 27 releases of three open-source software systems: ArgoUML, Mylyn, and Rhino. Specifically, the study analyzes the mutations of anti-patterns, the changes that they undergo, and the relation between anti-pattern evolution behaviours and fault-proneness. Results show that (1) anti-patterns mutate from one type of anti-patterns to another, (2) structural changes are behind these mutations, and (3) some mutations are more risky in terms of fault-proneness.},
	Author = {Jaafar, Fehmi and Khomh, Foutse and Gueheneuc, Yann-Gael and Zulkernine, Mohammad},
	Date-Added = {2019-05-07 01:07:43 +0100},
	Date-Modified = {2020-10-24 20:29:48 +0100},
	Doi = {10.1109/qsic.2014.45},
	Isbn = {9781479971978},
	Journal = {2014 14th International Conference on Quality Software},
	Keywords = {Anti-patterns; Fault proneness; Markov Chain},
	Pages = {246-255},
	Publisher = {IEEE},
	Title = {Anti-pattern Mutations and Fault-proneness},
	Url = {http://dx.doi.org/10.1109/QSIC.2014.45},
	Year = {2014},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/QSIC.2014.45},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/qsic.2014.45}}

@inproceedings{Jaafar:2017,
	Abstract = {In software engineering, a smell is a part of a software system's source code with a poor quality and that may indicate a deeper problem. Although many kinds of smells have been studied to analyze their causes, their behavior, and their impact on software quality, those smells typically are studied independently from each other. However, if two smells coincide inside a class, this could increases their negative effect (e.g., spaghetti code that is being cloned across the system). In this paper we report results from an empirical study conducted to examine the relationship between two specific kinds of smells: code clones and antipatterns. We conducted our study on three open-source software systems: Azureus, Eclipse, and JHotDraw. Results show that between 32% and 63% of classes in the analysed systems present co-occurrence of smells, and that such classes are more risky in term of fault-proneness.},
	Author = {F. {Jaafar} and A. {Lozano} and Y. {Gu{\'e}h{\'e}neuc} and K. {Mens}},
	Booktitle = {2017 IEEE International Conference on Software Quality, Reliability and Security (QRS)},
	Date-Added = {2019-05-07 01:06:53 +0100},
	Date-Modified = {2020-10-22 14:34:11 +0100},
	Doi = {10.1109/QRS.2017.38},
	Keywords = {public domain software;software engineering;open-source software systems;software engineering;Azureus;Eclipse;JHotDraw;clones;anti patterns;Cloning;Software systems;Maintenance engineering;Software quality;Measurement;Complexity theory;Code smells;Anti-patterns;Clones;Faults proneness;Software Quality},
	Pages = {274-284},
	Title = {On the Analysis of Co-Occurrence of Anti-Patterns and Clones},
	Year = {2017},
	Bdsk-Url-1 = {https://doi.org/10.1109/QRS.2017.38}}

@article{Jaafar:2013,
	Abstract = {Anti-patterns describe poor solutions to design and implementation problems which are claimed to make object oriented systems hard to maintain. Anti-patterns indicate weaknesses in design that may slow down development or increase the risk of faults or failures in the future. Classes in anti-patterns have some dependencies, such as static relationships, that may propagate potential problems to other classes. To the best of our knowledge, the relationship between anti-patterns dependencies (with non anti-patterns classes) and faults has yet to be studied in details. This paper presents the results of an empirical study aimed at analysing anti-patterns dependencies in three open source software systems, namely ArgoUML, JFreeChart, and XerecesJ. We show that, in almost all releases of the three systems, classes having dependencies with anti-patterns are more fault-prone than others. We also report other observations about these dependencies such as their impact on fault prediction. Software organizations could make use of these knowledge about anti-patterns dependencies to better focus their testing and reviews activities toward the most risky classes, e.g., classes with fault-prone dependencies with anti-patterns.},
	Author = {Jaafar, Fehmi and Gueheneuc, Yann-Gael and Hamel, Sylvie and Khomh, Foutse},
	Date-Added = {2019-05-07 01:06:15 +0100},
	Date-Modified = {2020-10-24 20:29:08 +0100},
	Doi = {10.1109/wcre.2013.6671310},
	Isbn = {9781479929313},
	Journal = {2013 20th Working Conference on Reverse Engineering (WCRE)},
	Keywords = {Anti-patterns; co-change; static relationships; mining software repositories; fault-proneness; empirical software engineering},
	Pages = {351-360},
	Publisher = {IEEE},
	Title = {Mining the relationship between anti-patterns dependencies and fault-proneness},
	Url = {http://dx.doi.org/10.1109/WCRE.2013.6671310},
	Year = {2013},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/WCRE.2013.6671310},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/wcre.2013.6671310}}

@inproceedings{Zhang:2017,
	Abstract = {To reduce loss from software defects, in the past decades, a number of software engineering researchers have proposed many software defect prediction techniques, which mainly focus on predicting the defect prone software modules, source code files, or code changes. Prior research have identified software design has significant impacts on software quality, especially the bad designs, e.g., anti-patterns, high dependency design, and large source code files, have made various software engineering tasks more difficult. Given these prior works, various bad designs indicators have been widely considered as the fundamental defect prediction metrics in various defect prediction models. Even though the performance of these techniques have been investigated empirically, researchers have not yet gained a clear understanding of correlation between these design metrics and defects proneness. To bridge this gap, in this paper, we investigate the impact of the three kinds of bad design indicators on software defect proneness by conducting a comprehensive empirical study on 18 release versions of the Apache Commons series. In details, we discuss the defect proneness on the file level of three kinds of bad designs, corresponding to seven defect proneness metrics, including various types of well defined code smells, high method dependency, and the files of large size. Furthermore, we investigate the performance of each defect proneness metrics and the overlap between the file sets involved in the bad designs. The experiment results indicate that the three types of bad designs do have impact on defect proneness, the files participating in some special code smell, the large number of code calls to other modules and the large number of lines of code are significantly more likely to be faulty. Moreover, the overlaps of three types of bad designs are relatively small, which means that each group of defect proneness metrics is independent of each other.},
	Author = {X. {Zhang} and Y. {Zhou} and C. {Zhu}},
	Booktitle = {2017 International Conference on Software Analysis, Testing and Evolution (SATE)},
	Date-Added = {2019-05-07 01:04:39 +0100},
	Date-Modified = {2020-10-22 14:33:26 +0100},
	Doi = {10.1109/SATE.2017.9},
	Keywords = {public domain software;software engineering;software fault tolerance;software maintenance;software metrics;software quality;software reliability;software engineering researchers;software defect prediction techniques;defect prone software modules;source code files;software design;software quality;high dependency design;software engineering tasks;bad designs indicators;fundamental defect prediction metrics;defect prediction models;design metrics;defects proneness;Measurement;Predictive models;Correlation;Software design;Software quality;Software engineering},
	Pages = {1-9},
	Title = {An Empirical Study of the Impact of Bad Designs on Defect Proneness},
	Year = {2017},
	Bdsk-Url-1 = {https://doi.org/10.1109/SATE.2017.9}}

@inproceedings{Karasneh:2016,
	Abstract = {There exists a large body of work on the specification and detection of anti-patterns in the source code of software systems. However, there are very few studies on the origins of the occurrences of anti-patterns in the source code: do the very design of the systems lead to the occurrences of anti-patterns or are anti-patterns introduced during implementation? Knowing when anti-patterns are introduced could help software designers and developers improve the quality of the source code, for example by eliminating fault-prone anti-patterns early during the design of the systems, even before their implementation. Therefore, we detect occurrences of anti-patterns in design models and in the source code of some systems, trace these occurrences between design and implementation, and study their relation and impact on the source code. First, we analyze both the UML design models and the source code of 10 open-source systems and show that antipatterns exist in design models. We observe that, on average, 37% of the classes in the design models that belong to anti-patterns also exist in the source code and also play roles in the same anti-patterns. Second, we investigate two open-source systems to assess the impact of the anti-patterns in their design models on the source code in terms of changes and faults. We show that classes that have anti-patterns in the design models have more changes and faults in the source code. Our results suggest that the design of the systems lead to anti-patterns and that the antipatterns impact negatively the change-and fault-proneness of the classes in the source code. Thus, designers should be wary of anti-patterns in their design models and could benefit from tools that detect and trace these anti-patterns into the source code.},
	Author = {B. {Karasneh} and M. R. V. {Chaudron} and F. {Khomh} and Y. {Gueheneuc}},
	Booktitle = {2016 IEEE 23rd International Conference on Software Analysis, Evolution, and Reengineering (SANER)},
	Date-Added = {2019-05-07 01:03:25 +0100},
	Date-Modified = {2020-10-22 14:32:52 +0100},
	Doi = {10.1109/SANER.2016.104},
	Keywords = {formal specification;public domain software;software fault tolerance;software quality;source code (software);Unified Modeling Language;design models;anti-pattern detection;software systems;source code quality;fault-prone anti-pattern elimination;UML design models;open-source systems;Anti-patterns;design models;source code},
	Pages = {36-45},
	Title = {Studying the Relation between Anti-Patterns in Design Models and in Source Code},
	Volume = {1},
	Year = {2016},
	Bdsk-Url-1 = {https://doi.org/10.1109/SANER.2016.104}}

@article{Taba:2013,
	Abstract = {Bug prediction models are often used to help allocate software quality assurance efforts. Software metrics (e.g., process metrics and product metrics) are at the heart of bug prediction models. However, some of these metrics like churn are not actionable, on the contrary, antipatterns which refer to specific design and implementation styles can tell the developers whether a design choice is "poor" or not. Poor designs can be fixed by refactoring. Therefore in this paper, we explore the use of antipatterns for bug prediction, and strive to improve the accuracy of bug prediction models by proposing various metrics based on antipatterns. An additional feature to our proposed metrics is that they take into account the history of antipatterns in files from their inception into the system. Through a case study on multiple versions of Eclipse and ArgoUML, we observe that (i) files participating in antipatterns have higher bug density than other files, (ii) our proposed antipattern based metrics can provide additional explanatory power over traditional metrics, and (iii) improve the F-measure of cross-system bug prediction models by 12.5% in average. Managers and quality assurance personnel can use our proposed metrics to better improve their bug prediction models and better focus testing activities and the allocation of support resources.},
	Author = {Taba, Seyyed Ehsan Salamati and Khomh, Foutse and Zou, Ying and Hassan, Ahmed E. and Nagappan, Meiyappan},
	Date-Added = {2019-05-07 01:02:35 +0100},
	Date-Modified = {2020-10-24 20:29:31 +0100},
	Doi = {10.1109/icsm.2013.38},
	Isbn = {9780769549811},
	Journal = {2013 IEEE International Conference on Software Maintenance},
	Keywords = {bug prediction; antipattern; software quality},
	Pages = {270-279},
	Publisher = {IEEE},
	Title = {Predicting Bugs Using Antipatterns},
	Url = {http://dx.doi.org/10.1109/ICSM.2013.38},
	Year = {2013},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/ICSM.2013.38},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/icsm.2013.38}}

@article{Ma:2015,
	Abstract = {The interactions between anti-patterns are claimed to affect maintenance. However, little work has been conducted to examine how anti-patterns interact. In this paper, we aim to investigate which pairs of anti-patterns tend to be coupled, i.e., interact with each other. We employ Fisher's exact test and Wilcoxon rank-sum test to identify coupled anti-patterns in the same class and coupled classes. Analyzing the relationships amongst 10 kinds of anti-patterns in five open-source projects, our results show that 1) several kinds of anti-patterns tend to be coupled, but some are conflicting, 2) the effect of anti-patterns on their dependent or co-changed ones are significant but small, 3) in ArgoUML, Xalan and Xerces-J, the classes infected with dependent anti-patterns are mostly (69.9% ~ 100%) modified in maintenance activities. Our findings offer empirical evidences for the existence of anti-pattern interactions, which provides valuable implications for practitioners and researchers.},
	Author = {Ma, Wanwangying and Chen, Lin and Zhou, Yuming and Xu, Baowen and Zhou, Xiaoyu},
	Date-Added = {2019-05-07 01:02:08 +0100},
	Date-Modified = {2020-10-24 20:31:27 +0100},
	Doi = {10.1109/qrs.2015.43},
	Isbn = {9781467379892},
	Journal = {2015 IEEE International Conference on Software Quality, Reliability and Security},
	Keywords = {anti-pattern; interaction; coupled; inter-pattern; maintenance},
	Pages = {242-251},
	Publisher = {IEEE},
	Title = {Are Anti-patterns Coupled? An Empirical Study},
	Url = {http://dx.doi.org/10.1109/QRS.2015.43},
	Year = {2015},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/QRS.2015.43},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/qrs.2015.43}}

@article{Abbes:2011,
	Abstract = {Antipatterns are "poor" solutions to recurring design problems which are conjectured in the literature to make object-oriented systems harder to maintain. However, little quantitative evidence exists to support this conjecture. We performed an empirical study to investigate whether the occurrence of antipatterns does indeed affect the understandability of systems by developers during comprehension and maintenance tasks. We designed and conducted three experiments, with 24 subjects each, to collect data on the performance of developers on basic tasks related to program comprehension and assessed the impact of two antipatterns and of their combinations: Blob and Spaghetti Code. We measured the developers' performance with: (1) the NASA task load index for their effort, (2) the time that they spent performing their tasks, and, (3) their percentages of correct answers. Collected data show that the occurrence of one antipattern does not significantly decrease developers' performance while the combination of two antipatterns impedes significantly developers. We conclude that developers can cope with one antipattern but that combinations of antipatterns should be avoided possibly through detection and refactorings.},
	Author = {Abbes, Marwen and Khomh, Foutse and Gueheneuc, Yann-Gael and Antoniol, Giuliano},
	Date-Added = {2019-05-07 01:01:18 +0100},
	Date-Modified = {2020-10-24 20:25:06 +0100},
	Doi = {10.1109/csmr.2011.24},
	Isbn = {9781612842592},
	Journal = {2011 15th European Conference on Software Maintenance and Reengineering},
	Keywords = {Antipatterns; Blob; Spaghetti Code; Program Comprehension; Program Maintenance; Empirical Software Engineering},
	Pages = {181-190},
	Publisher = {IEEE},
	Title = {An Empirical Study of the Impact of Two Antipatterns, Blob and Spaghetti Code, on Program Comprehension},
	Url = {http://dx.doi.org/10.1109/CSMR.2011.24},
	Year = {2011},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/CSMR.2011.24},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/csmr.2011.24}}

@article{Charalampidou:2017,
	Abstract = {An important parameter in deciding to eliminate technical debt (TD) is the probability of a module to generate interest along software evolution. In this study, we explore code smells, which according to practitioners are the most commonly occurring type of TD in industry, by assessing the associated interest probability. As a proxy of smell interest probability we use the frequency of smell occurrences and the change proneness of the modules in which they are identified. To achieve this goal we present a case study on 47,751 methods extracted from two well-known open source projects. The results of the case study suggest that: (a) modules in which "code smells" are concentrated are more change-prone than smell-free modules, (b) there are specific types of "code smells" that are concentrated in the most change-prone modules, and (c) interest probability of code clones seems to be higher than the other two examined code smells. These results can be useful for both researchers and practitioners, in the sense that the former can focus their research on resolving "code smells" that produce more interest, and the latter can improve accordingly the prioritization of their repayment strategy and their training.},
	Author = {Charalampidou, Sofia and Ampatzoglou, Apostolos and Chatzigeorgiou, Alexander and Avgeriou, Paris},
	Date-Added = {2019-05-07 00:59:56 +0100},
	Date-Modified = {2020-10-24 20:34:37 +0100},
	Doi = {10.1145/3120459.3120465},
	Isbn = {9781450352642},
	Journal = {Proceedings of the XP2017 Scientific Workshops on - XP '17},
	Keywords = {case study; technical debt; interest probability; change proneness},
	Pages = {8},
	Publisher = {ACM Press},
	Title = {Assessing Code Smell Interest Probability: A Case Study},
	Url = {http://dx.doi.org/10.1145/3120459.3120465},
	Year = {2017},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/3120459.3120465}}

@inproceedings{Soh:2016,
	Abstract = {Empirical studies have shown so far that code smells have relatively low impact over maintenance effort at file level. We surmise that previous studies have found low effects of code smells because the effort considered is a "sheer-effort" that does not distinguish between the kinds of developers' activities. In our study, we investigate the effects of code smells at the activity level. Examples of activities are: reading, editing, searching, and navigating, which are performed independently over different files during maintenance. We conjecture that structural attributes represented in the form of different code smells do indeed have an effect on the effort for performing certain kinds of activities. To verify this conjecture, we revisit a previous study about the impact of code smell on maintenance effort, using the same dataset, but considering activity effort. Six professional developers were hired to perform three maintenance tasks on four functionally equivalent Java Systems. Each developer performs two maintenance tasks. During maintenance task, we monitor developers' logs. Then, we define an annotation schema to identify developers' activities and assess whether code smells affect different maintenance activities. Results show that different code smells affect differently activity effort. Yet, the size of the changes performed to solve the task impacts the effort of all activities more than code smells and file size. While code smells impact the editing and navigating effort more than file size, the file size impacts the reading and searching activities more than code smells. One major implication of these results is that if code smells indeed affect the effort of certain kinds of activities, it means that their effects are contingent on the type of maintenance task at hand, where some kinds of activities will become more predominant than others.},
	Author = {Z. {Soh} and A. {Yamashita} and F. {Khomh} and Y. {Gu{\'e}h{\'e}neuc}},
	Booktitle = {2016 IEEE 23rd International Conference on Software Analysis, Evolution, and Reengineering (SANER)},
	Date-Added = {2019-05-07 00:59:00 +0100},
	Date-Modified = {2020-10-22 14:31:44 +0100},
	Doi = {10.1109/SANER.2016.103},
	Keywords = {file organisation;Java;software maintenance;software quality;maintenance programming activities;code smells;file level;structural attributes;maintenance effort;functionally equivalent Java systems;developer log monitoring;annotation schema;file size;Maintenance engineering;Navigation;Java;Programming;Software;Companies;Software engineering;code smells;programming activity;maintenance effort;program comprehension;software quality},
	Pages = {393-402},
	Title = {Do Code Smells Impact the Effort of Different Maintenance Programming Activities?},
	Volume = {1},
	Year = {2016},
	Bdsk-Url-1 = {https://doi.org/10.1109/SANER.2016.103}}

@inproceedings{Palomba:2017,
	Abstract = {Previous research demonstrated how code smells (i.e., symptoms of the presence of poor design or implementation choices) threat software maintainability. Moreover, some studies showed that their interaction has a stronger negative impact on the ability of developers to comprehend and enhance the source code when compared to cases when a single code smell instance affects a code element (i.e., a class or a method). While such studies analyzed the effect of the co-presence of more smells from the developers' perspective, a little knowledge regarding which code smell types tend to co-occur in the source code is currently available. Indeed, previous papers on smell co-occurrence have been conducted on a small number of code smell types or on small datasets, thus possibly missing important relationships. To corroborate and possibly enlarge the knowledge on the phenomenon, in this paper we provide a large-scale replication of previous studies, taking into account 13 code smell types on a dataset composed of 395 releases of 30 software systems. Code smell co-occurrences have been captured by using association rule mining, an unsupervised learning technique able to discover frequent relationships in a dataset. The results highlighted some expected relationships, but also shed light on co-occurrences missed by previous research in the field.},
	Author = {F. {Palomba} and R. {Oliveto} and A. {De Lucia}},
	Booktitle = {2017 IEEE Workshop on Machine Learning Techniques for Software Quality Evaluation (MaLTeSQuE)},
	Date-Added = {2019-05-07 00:58:07 +0100},
	Date-Modified = {2020-10-22 14:33:54 +0100},
	Doi = {10.1109/MALTESQUE.2017.7882010},
	Keywords = {data mining;software maintenance;code smell co-occurrences;association rule learning;software maintainability;source code;smell co-presence;software system releases;unsupervised learning technique;frequent relationship discovery;Context;Software systems;Data mining;Manuals;Software maintenance;Computer bugs;Code Smells;Empirical Studies;Association Rule Mining},
	Pages = {8-13},
	Title = {Investigating code smell co-occurrences using association rule learning: A replicated study},
	Year = {2017},
	Bdsk-Url-1 = {https://doi.org/10.1109/MALTESQUE.2017.7882010}}

@inproceedings{Kaur:2016,
	Abstract = {The objective of this paper is to study the relationship between different types of object-oriented software metrics, code smells and actual changes in software code that occur during maintenance period. It is hypothesized that code smells are indicators of maintenance problems. To understand the relationship between code smells and maintenance problems, we extract code smells in a Java based mobile application called MOBAC. Four versions of MOBAC are studied. Machine learning techniques are applied to predict software change-proneness with code smells as predictor variables. The results of this paper indicate that codes smells are more accurate predictors of change-proneness than static code metrics for all machine learning methods. However, class imbalance techniques did not outperform class balance machine learning techniques in change-proneness prediction. The results of this paper are based on accuracy measures such as F-measure and area under ROC curve},
	Author = {A. {Kaur} and K. {Kaur} and S. {Jain}},
	Booktitle = {2016 International Conference on Advances in Computing, Communications and Informatics (ICACCI)},
	Date-Added = {2019-05-07 00:56:56 +0100},
	Date-Modified = {2020-10-22 14:32:19 +0100},
	Doi = {10.1109/ICACCI.2016.7732136},
	Keywords = {Java;learning (artificial intelligence);object-oriented methods;software maintenance;software metrics;software change-proneness;code smells;class imbalance learning;object-oriented software metrics;maintenance problems;Java based mobile application;MOBAC;machine learning techniques;Software;Maintenance engineering;Couplings;Software metrics;Informatics;Data collection;Code smells;Exception handling smells;Software change-proneness;Machine learning techniques;Class imbalance learning},
	Pages = {746-754},
	Title = {Predicting software change-proneness with code smells and class imbalance learning},
	Year = {2016},
	Bdsk-Url-1 = {https://doi.org/10.1109/ICACCI.2016.7732136}}

@inproceedings{Zhao:2015,
	Abstract = {Code smell is any symptom in the source code of a program that possibly indicates a deeper problem. Though code smells are usually not proper bugs which are defined as technically incorrect and functionality block, they indicate poor programming practices in code level which increases risk of bugs in the future. Long method smell is identified as a kind of methods which are have large number of executable statements, at the same time God method smell is identified as a kind of methods which is doing too much. On the previous research and practice, people treat these 2 concepts equivalently. However, the definition of "large number of executable statements" shows us the size of the method, and at the same time definition of "doing too much" shows us the complexity of the logic which is implemented and nested in this method. Though intuitively the two definitions are equivalent -- methods with large number of statement means it nests much business logic so that the complexity of these methods is high, a dearth of studies suggest the research of difference between these two definitions. In this paper, present 2 research questions to study these 2 definitions. We choose one release of 11 java based web application projects which is in maintenance period respectively. In these releases, we ask the developers to analysis the bug reports and related code, then collect all 125 bugs which is caused by code smell and the related code for fixing these bugs. We get 45 bugs caused by the Long method smell and the related 31 methods, and we analyzed the data compared with the longest methods in these projects. The study highlights the need for a clearer definition of this kind of code smell, and there are many factors not only length which is affecting the code quality. So the real thing which is affecting the code quality is beyond the definition of "large number of executable statement", and at the same time the definition of "doing too much" should be modeling to illuminate this kind of code smell.},
	Author = {X. {Zhao} and X. {Xuan} and S. {Li}},
	Booktitle = {2015 30th IEEE/ACM International Conference on Automated Software Engineering Workshop (ASEW)},
	Date-Added = {2019-05-07 00:56:11 +0100},
	Date-Modified = {2020-10-22 14:30:51 +0100},
	Doi = {10.1109/ASEW.2015.15},
	Keywords = {Java;software engineering;source code (software);Java based Web application projects;God method smell;Long method smell;God method;program source code;Complexity theory;Computer bugs;Java;Maintenance engineering;Size measurement;Business;Time measurement},
	Pages = {109-114},
	Title = {An Empirical Study of Long Method and God Method in Industrial Projects},
	Year = {2015},
	Bdsk-Url-1 = {https://doi.org/10.1109/ASEW.2015.15}}

@inproceedings{Islam:2016,
	Abstract = {Code clones are serious code smells. To investigate bug-proneness of clones as opposed to clone-free source code, earlier attempts have studied the stability of code clones and their contributions to program faults. This paper presents a comparative study on different types of clones and non-cloned code on the basis of their vulnerabilities, which may lead to software defects and issues in future. The empirical study along this new dimension examines source code of 97 software systems and derives results based on quantitative analysis with statistical significance. The findings from this work add to our under-standing of the characteristics and impacts of clones, which can be useful in clone-aware software development and in devising techniques for minimizing the negative impacts of code clones.},
	Author = {M. R. {Islam} and M. F. {Zibran}},
	Booktitle = {2016 IEEE 23rd International Conference on Software Analysis, Evolution, and Reengineering (SANER)},
	Date-Added = {2019-05-07 00:55:12 +0100},
	Date-Modified = {2020-10-22 14:31:07 +0100},
	Doi = {10.1109/SANER.2016.90},
	Keywords = {software engineering;source code (software);noncloned code;code clones;code smells;bug-proneness;clone-free source code;program faults;software systems;clone-aware software development;Cloning;Software systems;Measurement;Maintenance engineering;Encoding;History},
	Pages = {8-14},
	Title = {A Comparative Study on Vulnerabilities in Categories of Clones and Non-cloned Code},
	Volume = {3},
	Year = {2016},
	Bdsk-Url-1 = {https://doi.org/10.1109/SANER.2016.90}}

@article{Walter:2016,
	Abstract = {Context---Design patterns represent recommended generic solutions to various design problems, whereas code smells are symptoms of design issues that could hinder further maintenance of a software system. We can intuitively expect that both concepts are mutually exclusive, and the presence of patterns is correlated with the absence of code smells. However, the existing experimental evidence supporting this claim is still insufficient, and studies separately analyzing the impact of smells and patterns on code quality deliver diverse results. Objective---The aim of the paper is threefold: (1) to determine if and how the presence of the design patterns is linked to the presence of code smells, (2) to investigate if and how these relationships change throughout evolution of code, and (3) to identify the relationships between individual patterns and code smells. Method---We analyze nine design patterns and seven code smells in two medium-size, long-evolving, open source Java systems. In particular, we explore how the presence of design patterns impacts the presence of code smells, analyze if this link evolves over time, and extract association rules that describe their individual relationships. Results---Classes participating in design patterns appear to display code smells less frequently than other classes. The observed effect is stronger for some patterns (e.g., Singleton, State-Strategy) and weaker for others (e.g., Composite). The ratio between the relative number of smells in the classes participating in patterns and the relative number of smells in other classes, is approximately stable or slightly decreasing in time. Conclusion---This observation could be used to anticipate the smell-proneness of individual classes, and improve code smell detectors. Overall, our findings indicate that the presence of design patterns is linked with a lower number of code smell instances. This could support programmers in a context-sensitive analysis of smells in code.},
	Author = {Bartosz Walter and Tarek Alkhaeir},
	Date-Added = {2019-05-07 00:53:55 +0100},
	Date-Modified = {2019-08-31 18:09:44 +0100},
	Doi = {10.1016/j.infsof.2016.02.003},
	Issn = {0950-5849},
	Journal = {Information and Software Technology},
	Keywords = {Design patterns, Code smells, Software evolution, Empirical study},
	Pages = {127 - 142},
	Title = {The relationship between design patterns and code smells: An exploratory study},
	Url = {http://www.sciencedirect.com/science/article/pii/S0950584916300210},
	Volume = {74},
	Year = {2016},
	Bdsk-Url-1 = {http://www.sciencedirect.com/science/article/pii/S0950584916300210},
	Bdsk-Url-2 = {https://doi.org/10.1016/j.infsof.2016.02.003}}

@inproceedings{Ma:2016,
	Abstract = {Code smells are used to describe code structures that may cause detrimental effects on software and should be refactored. Previous studies show that some code smells have significant effect on faults. However, how to refactor code smells to reduce bugs still needs more concern. We investigate the possibility of prioritizing code smell refactoring with the help of fault prediction results. We also investigate the possibility of improving the performance of fault prediction by using code smell detection results. We use Cohen's Kappa statistic to report agreements between results of code smell detections and fault predictions. We use fault prediction result as an indicator to guide code smell refactoring. Our results show that refactoring Blob, Long Parameter List, and Refused Parent Be Request may have a good chance to detect and fix bugs, and some code smells are particularly useful for improving the recall of fault prediction.},
	Author = {W. {Ma} and L. {Chen} and Y. {Zhou} and B. {Xu}},
	Booktitle = {2016 International Conference on Software Analysis, Testing and Evolution (SATE)},
	Date-Added = {2019-05-07 00:52:49 +0100},
	Date-Modified = {2020-10-22 14:32:01 +0100},
	Doi = {10.1109/SATE.2016.11},
	Keywords = {program debugging;software fault tolerance;software maintenance;software performance evaluation;bugs;code structures;code smell detection;Kappa statistic;code smell refactoring;Refused Parent Be Request;Long Parameter List;Blob;fault prediction performance improvement;Computer bugs;Measurement;Software;Object oriented modeling;Predictive models;Complexity theory;Logistics;Code smell;refactoring;refactoring prioritization;fault prediction},
	Pages = {24-29},
	Title = {Do We Have a Chance to Fix Bugs When Refactoring Code Smells?},
	Year = {2016},
	Bdsk-Url-1 = {https://doi.org/10.1109/SATE.2016.11}}

@inproceedings{Reis:2016,
	Abstract = {Background: Code smells are considered detrimental to maintainability. To plan QA preventive initiatives (e.g. refactoring actions) it is important to know if the application domain is likely to affect the incidence of those problems. Objective: The main goal of this paper is to check if the application domain has a statistically significant impact on the incidence of code smells. Methods: We conducted a quasi-experiment using 118 Java applications, classified into 6 application domains, and including 7 types of code smells. To test the formulated hypotheses, we used the Kruskal-Wallis and ANOVA tests. Results: Our results show that the incidence of most code smells does not depend on the application domain, with the exception of Duplicated Code smell, where it was found that its incidence in the domain Home & Education is superior to the others. Limitations: This study was based on medium sized open source applications written in Java. Therefore, its external validity will be questionable outside this scope. Conclusions: For 6 out of 7 code smell types, our results corroborate previous studies where no difference could be found on code smells incidence across applications. However, statistically significant differences were found for the Duplicated Code (aka Clone) smell. This result confirmed the claim produced by Martin Fowler almost 20 years ago that software clones may be induced by the application domain.},
	Author = {J. P. d. {Reis} and F. {Brito e Abreu} and G. d. F. {Carneiro}},
	Booktitle = {2016 10th International Conference on the Quality of Information and Communications Technology (QUATIC)},
	Date-Added = {2019-05-07 00:51:57 +0100},
	Date-Modified = {2020-10-22 14:31:24 +0100},
	Doi = {10.1109/QUATIC.2016.044},
	Keywords = {software maintenance;software metrics;software quality;statistical analysis;statistical testing;software maintainability;QA preventive initiatives;software refactoring;application domain;Java applications;Kruskal-Wallis test;ANOVA test;open source applications;statistical analysis;duplicated code smell;software clones;Software;Complexity theory;Measurement;Education;Java;Business;Games;software quality;code smells;application domain;complexity metrics.},
	Pages = {172-177},
	Title = {Code Smells Incidence: Does It Depend on the Application Domain?},
	Year = {2016},
	Bdsk-Url-1 = {https://doi.org/10.1109/QUATIC.2016.044}}

@inproceedings{Palomba:2016,
	Abstract = {Code smells are symptoms of poor design and implementation choices. Previous studies empirically assessed the impact of smells on code quality and clearly indicate their negative impact on maintainability, including a higher bug-proneness of components affected by code smells. In this paper we capture previous findings on bug-proneness to build a specialized bug prediction model for smelly classes. Specifically, we evaluate the contribution of a measure of the severity of code smells (i.e., code smell intensity) by adding it to existing bug prediction models and comparing the results of the new model against the baseline model. Results indicate that the accuracy of a bug prediction model increases by adding the code smell intensity as predictor. We also evaluate the actual gain provided by the intensity index with respect to the other metrics in the model, including the ones used to compute the code smell intensity. We observe that the intensity index is much more important as compared to other metrics used for predicting the buggyness of smelly classes.},
	Author = {F. {Palomba} and M. {Zanoni} and F. A. {Fontana} and A. D. {Lucia} and R. {Oliveto}},
	Booktitle = {2016 IEEE International Conference on Software Maintenance and Evolution (ICSME)},
	Date-Added = {2019-05-07 00:50:21 +0100},
	Date-Modified = {2020-10-22 14:32:35 +0100},
	Doi = {10.1109/ICSME.2016.27},
	Keywords = {program debugging;software performance evaluation;source code (software);bug prediction performance improvement;code smell intensity index;bug-proneness;Measurement;Computer bugs;Predictive models;Indexes;Context;Object oriented modeling;Computational modeling;Code Smells;Bug Prediction},
	Pages = {244-255},
	Title = {Smells Like Teen Spirit: Improving Bug Prediction Performance Using the Intensity of Code Smells},
	Year = {2016},
	Bdsk-Url-1 = {https://doi.org/10.1109/ICSME.2016.27}}

@article{Yamashita:2013,
	Abstract = {Code smells are indicators of deeper design problems that may cause difficulties in the evolution of a software system. This paper investigates the capability of twelve code smells to reflect actual maintenance problems. Four medium-sized systems with equivalent functionality but dissimilar design were examined for code smells. Three change requests were implemented on the systems by six software developers, each of them working for up to four weeks. During that period, we recorded problems faced by developers and the associated Java files on a daily basis. We developed a binary logistic regression model, with ``problematic file'' as the dependent variable. Twelve code smells, file size, and churn constituted the independent variables. We found that violation of the Interface Segregation Principle (a.k.a. ISP violation) displayed the strongest connection with maintenance problems. Analysis of the nature of the problems, as reported by the developers in daily interviews and think-aloud sessions, strengthened our view about the relevance of this code smell. We observed, for example, that severe instances of problems relating to change propagation were associated with ISP violation. Based on our results, we recommend that code with ISP violation should be considered potentially problematic and be prioritized for refactoring.},
	Author = {Yamashita, Aiko},
	Date-Added = {2019-05-07 00:48:55 +0100},
	Date-Modified = {2020-10-22 14:15:53 +0100},
	Doi = {10.1007/s10664-013-9250-3},
	Issn = {1573-7616},
	Journal = {Empirical Software Engineering},
	Keywords = {Software maintenance; Code smells; Refactoring; Maintenance problems},
	Number = {4},
	Pages = {1111--1143},
	Publisher = {Springer Nature},
	Title = {Assessing the capability of code smells to explain maintenance problems: an empirical study combining quantitative and qualitative data},
	Url = {http://dx.doi.org/10.1007/s10664-013-9250-3},
	Volume = {19},
	Year = {2013},
	Bdsk-Url-1 = {http://dx.doi.org/10.1007/s10664-013-9250-3}}

@article{Cardoso:2015,
	Abstract = {A design pattern is a general reusable solution to a recurring problem in software design. Bad smells are symptoms that may indicate something wrong in the system design or code. Therefore, design patterns and bad smells represent antagonistic structures. They are subject of recurring research and typically appear in software systems. Although design patterns represent good design, their use is often inadequate because their implementation is not always trivial or they may be unnecessarily employed. The inadequate use of design patterns may lead to a bad smell. Therefore, this paper performs an exploratory study in order to identify instances of co-occurrences of design patterns and bad smells. This study is performed over five systems and discovers some co-occurrences between design patterns and bad smells. For instance, we observed the co-occurrences of Command with God Class and Template Method with Duplicated Code. The results of this study make it possible to understand in which situations design patterns are misused or overused and establish guidelines for their better use.},
	Author = {Bruno Cardoso and Eduardo Figueiredo},
	Date-Added = {2019-05-07 00:46:45 +0100},
	Date-Modified = {2020-10-24 20:33:15 +0100},
	Journal = {Proceedings of the XI Brazilian Symposium on Information Systems (SBSI 2015)},
	Keywords = {Design Patterns; Bad Smells},
	Pages = {347--354},
	Title = {Co-Occurrence of Design Patterns and Bad Smells in Software Systems: An Exploratory Study},
	Url = {https://aisel.aisnet.org/sbis2015/55},
	Year = {2015},
	Bdsk-Url-1 = {https://aisel.aisnet.org/sbis2015/55}}

@article{Santos:2015,
	Abstract = {Context: Code smells define potential problems in design of software. However, some empirical studies on the topic have shown findings in opposite direction. The misunderstanding is mainly caused by lack of works focusing on human role on code smell detection. Objective: Our aim is to build empirical support to exploration of the human role on code smell detection. specifically, we investigated what issues in code make a human identify a class as a code smell. We called these issues decision drivers. Method: We performed a controlled experiment and replicated it twice. We asked participants to detect god class (one of the most known smell) on different software, indicating what decision drivers they adopted. Results: The stronger drivers were "class is high complex" and "method is misplaced". We also found the agreement on drivers' choice is low. Another finding is: some important drivers are dependent of alternative support. In our case, "dependency" was an important driver only when visual resources were permitted. Conclusion: This study contributes with the comprehension of the human role on smell detection through the exploration of decision drivers. This perception contributes to characterize what we called the "code smell conceptualization problem".},
	Author = {Santos, Jos{\'e} Amancio M. and de Mendon{\c c}a, Manoel G.},
	Date-Added = {2019-05-07 00:45:22 +0100},
	Date-Modified = {2020-10-24 20:33:34 +0100},
	Doi = {10.1145/2695664.2695682},
	Isbn = {9781450331968},
	Journal = {Proceedings of the 30th Annual ACM Symposium on Applied Computing - SAC '15},
	Keywords = {controlled experiment; god class; code smell; empirical study; decision drivers},
	Pages = {1472--1479},
	Publisher = {ACM Press},
	Title = {Exploring decision drivers on god class detection in three controlled experiments},
	Url = {http://dx.doi.org/10.1145/2695664.2695682},
	Year = {2015},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/2695664.2695682}}

@article{Linares_Vasquez:2014,
	Abstract = {Some previous work began studying the relationship between application domains and quality, in particular through the prevalence of code and design smells (e.g., anti-patterns). Indeed, it is generally believed that the presence of these smells degrades quality but also that their prevalence varies across domains. Though anecdotal experiences and empirical evidence gathered from developers and researchers support this belief, there is still a need to further deepen our understanding of the relationship between application domains and quality. Consequently, we present a large-scale study that investigated the systematic relationships between the presence of smells and quality-related metrics computed over the bytecode of 1,343 Java Mobile Edition applications in 13 different application domains. Although, we did not find evidence of a correlation between smells and quality- related metrics, we found (1) that larger differences exist between metric values of classes exhibiting smells and classes without smells and (2) that some smells are commonly present in all the domains while others are most prevalent in certain domains},
	Author = {Linares-V{\'a}squez, Mario and Klock, Sam and McMillan, Collin and Saban{\'e}, Aminata and Poshyvanyk, Denys and Gu{\'e}h{\'e}neuc, Yann-Ga{\"e}l},
	Date-Added = {2019-05-07 00:44:35 +0100},
	Date-Modified = {2020-10-24 20:30:32 +0100},
	Doi = {10.1145/2597008.2597144},
	Isbn = {9781450328791},
	Journal = {Proceedings of the 22nd International Conference on Program Comprehension - ICPC 2014},
	Keywords = {Domain categories; Internal metrics; Anti-patterns; Software quality; Java Mobile Edition},
	Pages = {232--243},
	Publisher = {ACM Press},
	Title = {Domain matters: bringing further evidence of the relationships among anti-patterns, application domains, and quality-related metrics in Java mobile apps},
	Url = {http://dx.doi.org/10.1145/2597008.2597144},
	Year = {2014},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/2597008.2597144}}

@article{Yamashita:2015,
	Abstract = {The presence of anti-patterns and code smells can affect adversely software evolution and quality. Recent work has shown that code smells that appear together in the same file (i.e., collocated smells) can interact with each other, leading to various types of maintenance issues and/or to the intensification of negative effects. It has also been found that code smell interactions can occur across coupled files (i.e., coupled smells), with comparable negative effects as the interaction of same-file (collocated) smells. Different inter-smell relations have been described in previous work, yet only few studies have evaluated them empirically. This study attempts to replicate the findings from previous work on inter-smell relations by analyzing larger systems, and by including both industrial and open source ones. We also include the analysis of coupled smells in addition to collocated smells, to achieve a more complete picture of inter-smell relations. Our results suggest that if coupled smells are not considered, one may risk increasing the number of false negatives when analysing inter-smells. A major finding is that patterns of inter-smell relations vary between open source and industrial systems, suggesting that contextual variables should be considered in further studies on code smells.},
	Author = {Yamashita, Aiko and Zanoni, Marco and Fontana, Francesca Arcelli and Walter, Bartosz},
	Date-Added = {2019-05-07 00:44:00 +0100},
	Date-Modified = {2020-10-24 20:33:57 +0100},
	Doi = {10.1109/icsm.2015.7332458},
	Isbn = {9781467375320},
	Journal = {2015 IEEE International Conference on Software Maintenance and Evolution (ICSME)},
	Keywords = {code smells; bad smells; inter-smell relations},
	Pages = {121-130},
	Publisher = {IEEE},
	Title = {Inter-smell relations in industrial and open source systems: A replication and comparative analysis},
	Url = {http://dx.doi.org/10.1109/ICSM.2015.7332458},
	Year = {2015},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/ICSM.2015.7332458},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/icsm.2015.7332458}}

@article{Tufano:2015,
	Abstract = {In past and recent years, the issues related to managing technical debt received significant attention by researchers from both industry and academia. There are several factors that contribute to technical debt. One of these is represented by code bad smells, i.e., Symptoms of poor design and implementation choices. While the repercussions of smells on code quality have been empirically assessed, there is still only anecdotal evidence on when and why bad smells are introduced. To fill this gap, we conducted a large empirical study over the change history of 200 open source projects from different software ecosystems and investigated when bad smells are introduced by developers, and the circumstances and reasons behind their introduction. Our study required the development of a strategy to identify smell-introducing commits, the mining of over 0.5M commits, and the manual analysis of 9,164 of them (i.e., Those identified as smell-introducing). Our findings mostly contradict common wisdom stating that smells are being introduced during evolutionary tasks. In the light of our results, we also call for the need to develop a new generation of recommendation systems aimed at properly planning smell refactoring activities.},
	Author = {Tufano, Michele and Palomba, Fabio and Bavota, Gabriele and Oliveto, Rocco and Di Penta, Massimiliano and De Lucia, Andrea and Poshyvanyk, Denys},
	Date-Added = {2019-05-07 00:43:28 +0100},
	Date-Modified = {2020-10-24 20:34:16 +0100},
	Doi = {10.1109/icse.2015.59},
	Isbn = {9781479919345},
	Journal = {2015 IEEE/ACM 37th IEEE International Conference on Software Engineering},
	Keywords = {bad code smells; mining software repositories; empirical study},
	Pages = {403-414},
	Publisher = {IEEE},
	Title = {When and Why Your Code Starts to Smell Bad},
	Url = {http://dx.doi.org/10.1109/ICSE.2015.59},
	Year = {2015},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/ICSE.2015.59},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/icse.2015.59}}

@article{Ahmed:2015,
	Abstract = {Context: Software decay is a key concern for large, long-lived software projects. Systems degrade over time as design and implementation compromises and exceptions pile up. Goal: Quantify design decay and understand how software projects deal with this issue. Method: We conducted an empirical study on the presence and evolution of code smells, used as an indicator of design degradation in 220 open source projects. Results: The best approach to maintain the quality of a project is to spend time reducing both software defects (bugs) and design issues (refactoring). We found that design issues are frequently ignored in favor of fixing defects. We also found that design issues have a higher chance of being fixed in the early stages of a project, and that efforts to correct these stall as projects mature and the code base grows, leading to a build-up of problems. Conclusions: From studying a large set of open source projects, our research suggests that while core contributors tend to fix design issues more often than non-core contributors, there is no difference once the relative quantity of commits is accounted for. We also show that design issues tend to build up over time.},
	Author = {Ahmed, Iftekhar and Mannan, Umme Ayda and Gopinath, Rahul and Jensen, Carlos},
	Date-Added = {2019-05-07 00:42:21 +0100},
	Date-Modified = {2020-10-24 20:31:08 +0100},
	Doi = {10.1109/esem.2015.7321186},
	Isbn = {9781467378994},
	Journal = {2015 ACM/IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM)},
	Keywords = {Software Decay; Design Problems; Project History},
	Pages = {1-10},
	Publisher = {IEEE},
	Title = {An Empirical Study of Design Degradation: How Software Projects Get Worse over Time},
	Url = {http://dx.doi.org/10.1109/ESEM.2015.7321186},
	Year = {2015},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/ESEM.2015.7321186},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/esem.2015.7321186}}

@article{Oizumi:2014,
	Abstract = {Several projects have been discontinued in the history of the software industry due to the presence of software architecture problems. The identification of such problems in source code is often required in real project settings, but it is a time-consuming and challenging task. Some authors assume that architectural problems are reflected in source code through individual code anomalies. However, each architectural problem may be realized by multiple code anomalies, which are intertwined in several program elements. The relationships of these various code anomalies and their architecture problems' counterparts are hard to reveal and characterize. In fact, there is little knowledge about the manifestation of code-anomaly agglomerations in software projects and when they adversely impact (or not) the software architecture. To overcome this limitation, we propose studying the architecture impact of a wide range of code-anomaly agglomerations. An agglomeration is a group of code anomalies that are related to each other for some reason - e.g. all of them affect syntactically-related code elements in the program. In our study, we analyzed a total of 5418 code anomalies and 2229 agglomerations within 7 systems. We observed that architectural problems are much more often reflected as anomaly agglomerations rather than individual anomalies in the source code. More importantly, we also revealed when code-anomaly agglomerations were (or not) good indicators of architectural problems. For instance, the result of our study suggests that certain topologies of code-anomaly agglomerations are better indicators than others.},
	Author = {Oizumi, Willian Nalepa and Garcia, Alessandro Fabricio and Colanzi, Thelma Elita and Ferreira, Manuele and Staa, Arndt von},
	Date-Added = {2019-05-07 00:41:32 +0100},
	Date-Modified = {2020-10-24 20:30:50 +0100},
	Doi = {10.1109/sbes.2014.18},
	Isbn = {9781479942237},
	Journal = {2014 Brazilian Symposium on Software Engineering},
	Keywords = {code anomaly; architectural problem; source code analysis},
	Pages = {91-100},
	Publisher = {IEEE},
	Title = {When Code-Anomaly Agglomerations Represent Architectural Problems? An Exploratory Study},
	Url = {http://dx.doi.org/10.1109/SBES.2014.18},
	Year = {2014},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/SBES.2014.18},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/sbes.2014.18}}

@article{Palomba:2014,
	Abstract = {In the last decade several catalogues have been defined to characterize bad code smells, i.e., symptoms of poor design and implementation choices. On top of such catalogues, researchers have defined methods and tools to automatically detect and/or remove bad smells. Nevertheless, there is an ongoing debate regarding the extent to which developers perceive bad smells as serious design problems. Indeed, there seems to be a gap between theory and practice, i.e., what is believed to be a problem (theory) and what is actually a problem (practice). This paper presents a study aimed at providing empirical evidence on how developers perceive bad smells. In this study, we showed to developers code entities -- belonging to three systems -- affected and not by bad smells, and we asked them to indicate whether the code contains a potential design problem, and if any, the nature and severity of the problem. The study involved both original developers from the three projects and outsiders, namely industrial developers and Master's students. The results provide insights on characteristics of bad smells not yet explored sufficiently. Also, our findings could guide future research on approaches for the detection and removal of bad smells.},
	Author = {Palomba, Fabio and Bavota, Gabriele and Penta, Massimiliano Di and Oliveto, Rocco and Lucia, Andrea De},
	Date-Added = {2019-05-07 00:40:23 +0100},
	Date-Modified = {2020-10-24 20:30:08 +0100},
	Doi = {10.1109/icsme.2014.32},
	Isbn = {9781479961467},
	Journal = {2014 IEEE International Conference on Software Maintenance and Evolution},
	Keywords = {Code Smells; Empirical Study},
	Pages = {101-110},
	Publisher = {IEEE},
	Title = {Do They Really Smell Bad? A Study on Developers' Perception of Bad Code Smells},
	Url = {http://dx.doi.org/10.1109/ICSME.2014.32},
	Year = {2014},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/ICSME.2014.32},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/icsme.2014.32}}

@article{Ban:2014,
	Abstract = {Similarly to design patterns and their inherent extra information about the structure and design of a system, antipatterns -- or bad code smells -- can also greatly influence the quality of software. Although the belief that they negatively impact maintainability is widely accepted, there are still relatively few objective results that would support this theory.

In this paper we show our approach of detecting antipatterns in source code by structural analysis and use the results to reveal connections among antipatterns, number of bugs, and maintainability. We studied 228 open-source Java based systems and extracted bug-related information for 34 of them from the PROMISE database. For estimating the maintainability, we used the ColumbusQM probabilistic quality model.

We found that there is a statistically significant, 0.55 Spearman correlation between the number of bugs and the number of antipatterns. Moreover, there is an even stronger, -0.62 reverse Spearman correlation between the number of antipatterns and code maintainability.

We also found that even these few implemented antipatterns could nearly match the machine learning based bug-predicting power of 50 class level source code metrics.

Although the presented analysis is not conclusive by far, these first results suggest that antipatterns really do decrease code quality and can highlight spots that require closer attention.},
	Author = {B{\'a}n, D{\'e}nes and Ferenc, Rudolf},
	Date-Added = {2019-05-07 00:39:36 +0100},
	Date-Modified = {2020-10-22 14:07:28 +0100},
	Doi = {10.1007/978-3-319-09156-3_25},
	Isbn = {9783319091563},
	Issn = {1611-3349},
	Journal = {Lecture Notes in Computer Science},
	Keywords = {Antipatterns; Software maintainability; Empirical validation; OO design; ISO/IEC 25010; SQuaRE},
	Pages = {337--352},
	Publisher = {Springer International Publishing},
	Title = {Recognizing Antipatterns and Analyzing Their Effects on Software Maintainability},
	Url = {http://dx.doi.org/10.1007/978-3-319-09156-3_25},
	Year = {2014},
	Bdsk-Url-1 = {http://dx.doi.org/10.1007/978-3-319-09156-3_25}}

@inproceedings{Santos:2014,
	Abstract = {Context: "Code smell" is commonly presented as indicative of problems in design of object-oriented systems. However, some empirical studies have presented findings refuting this idea. One of the reasons of the misunderstanding is the low number of studies focused on the role of human on code smell detection. Objective: Our aim is to build empirical support to exploration of the human role on code smell detection. Specifically, we investigated strategies adopted by developers on god class detection. God class is one of the most known code smell. Method: We performed a controlled experiment and replicated it. We explored the strategies from the participant's actions logged during the detection of god classes. Result: One of our findings was that the observation of coupling is more relevant than the observation of attributes like LOC or complexity and the hierarchical relation among these. We also noted that reading source code is important, even with visual resources enha ncing the general comprehension of the software. Conclusion: This study contributes to expand the comprehension of the human role on code smell detection through the use of automatic logging. We suggest that this approach brings a complementary perspective of analysis in discussions about the topic.},
	Author = {Jos{\'{e}} Amancio M. Santos and Manoel G. Mendon{\c{c}}a},
	Booktitle = {SEKE},
	Date-Added = {2019-05-07 00:37:23 +0100},
	Date-Modified = {2020-10-22 14:08:25 +0100},
	Keywords = {Code smell; god class; controlled experiment},
	Pages = {244--249},
	Publisher = {Knowledge Systems Institute Graduate School},
	Title = {Identifying strategies on god class detection in two controlled experiments},
	Year = {2014}}

@article{Fontana:2013,
	Abstract = {There are various activities that support software maintenance. Program comprehension and detection of design anomalies and their symptoms, like code smells and anti patterns, are particularly relevant for improving the quality and facilitating evolution of a system. In this paper we describe an empirical study on the detection of code smells, aiming at identifying the most frequent smells in systems of different domains and hence the domains characterized by more smells. Moreover, we study possible correlations existing among smells and the values of a set of software quality metrics using Spearman's rank correlation and Principal Component Analysis.},
	Author = {Fontana, Francesca Arcelli and Ferme, Vincenzo and Marino, Alessandro and Walter, Bartosz and Martenka, Pawel},
	Date-Added = {2019-05-07 00:35:22 +0100},
	Date-Modified = {2020-10-24 20:28:50 +0100},
	Doi = {10.1109/icsm.2013.37},
	Isbn = {9780769549811},
	Journal = {2013 IEEE International Conference on Software Maintenance},
	Keywords = {software maintenance; software evolution; code smell detection; metric and smell correlations; domain-dependent analysis},
	Pages = {260-269},
	Publisher = {IEEE},
	Title = {Investigating the Impact of Code Smells on System's Quality: An Empirical Study on Systems of Different Application Domains},
	Url = {http://dx.doi.org/10.1109/ICSM.2013.37},
	Year = {2013},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/ICSM.2013.37},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/icsm.2013.37}}

@article{Yamashita:2013b,
	Abstract = {Code smells are a well-known metaphor to describe symptoms of code decay or other issues with code quality which can lead to a variety of maintenance problems. Even though code smell detection and removal has been well-researched over the last decade, it remains open to debate whether or not code smells should be considered meaningful conceptualizations of code quality issues from the developer's perspective. To some extent, this question applies as well to the results provided by current code smell detection tools. Are code smells really important for developers? If they are not, is this due to the lack of relevance of the underlying concepts, due to the lack of awareness about code smells on the developers' side, or due to the lack of appropriate tools for code smell analysis or removal? In order to align and direct research efforts to address actual needs and problems of professional developers, we need to better understand the knowledge about, and interest in code smells, together with their perceived criticality. This paper reports on the results obtained from an exploratory survey involving 85 professional software developers.},
	Author = {Yamashita, Aiko and Moonen, Leon},
	Date-Added = {2019-05-07 00:34:32 +0100},
	Date-Modified = {2020-10-24 20:28:09 +0100},
	Doi = {10.1109/wcre.2013.6671299},
	Isbn = {9781479929313},
	Journal = {2013 20th Working Conference on Reverse Engineering (WCRE)},
	Keywords = {maintainability; code smells; survey; code smell detection; code analysis tools; usability; refactoring},
	Pages = {242-251},
	Publisher = {IEEE},
	Title = {Do developers care about code smells? An exploratory survey},
	Url = {http://dx.doi.org/10.1109/WCRE.2013.6671299},
	Year = {2013},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/WCRE.2013.6671299},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/wcre.2013.6671299}}

@inproceedings{Mantyla:2005,
	Abstract = {Recent trends in software development have emphasized the importance of refactoring in preserving software evolvability. We performed two experiments on software evolvability evaluation, i.e. evaluating the existence of certain code problems called code smells and the refactoring decision. We studied the agreement of the evaluators. Interrater agreement was high for simple code smells and low for the refactoring decision. Furthermore, we analyzed evaluators' demographics and source code metrics as factors explaining the evaluations. The code metrics explained over 70% of the variation regarding the simple code smell evaluations, but only about 30% of the refactoring decision. Surprisingly, the demographics were not useful predictors neither for evaluating code smells nor the refactoring decision. The low agreement for the refactoring decisions may indicate difficulty in building tool support simulating real-life subjective refactoring decisions. However, code metrics tools should be effective in highlighting straightforward problems, e.g. simple code smells.},
	Author = {M. V. {Mantyla}},
	Booktitle = {2005 International Symposium on Empirical Software Engineering, 2005.},
	Date-Added = {2019-05-07 00:33:40 +0100},
	Date-Modified = {2020-10-22 14:30:27 +0100},
	Doi = {10.1109/ISESE.2005.1541837},
	Keywords = {object-oriented programming;software metrics;object-oriented software;interrater agreement;software development;software evolvability evaluation;refactoring decision;evaluator demographics analysis;source code metrics;code smell evaluation;Software quality;Software performance;Demography;Humans;Programming profession;Performance evaluation;Object oriented modeling;Software systems},
	Pages = {10},
	Title = {An experiment on subjective evolvability evaluation of object-oriented software: explaining factors and interrater agreement},
	Year = {2005},
	Bdsk-Url-1 = {https://doi.org/10.1109/ISESE.2005.1541837}}

@inproceedings{Mantyla:2004,
	Abstract = {This work presents the results of an initial empirical study on the subjective evaluation of bad code smells, which identify poor structures in software. Based on a case study in a Finnish software product company, we make two contributions. First, we studied the evaluator effect when subjectively evaluating the existence of smells in code modules. We found that the use of smells for code evaluation purposes is hard due to conflicting perceptions of different evaluators. Second, we applied source code metrics for identifying three smells and compared these results to the subjective evaluations. Surprisingly, the metrics and smell evaluations did not correlate.},
	Author = {M. V. {Mantyla} and J. {Vanhanen} and C. {Lassenius}},
	Booktitle = {20th IEEE International Conference on Software Maintenance, 2004. Proceedings.},
	Date-Added = {2019-05-07 00:31:47 +0100},
	Date-Modified = {2020-10-22 14:30:12 +0100},
	Doi = {10.1109/ICSM.2004.1357825},
	Issn = {1063-6773},
	Keywords = {program diagnostics;software houses;software metrics;software performance evaluation;subjective evaluation;bad code smell;poor software structures;Finnish software product company;code modules;code evaluation;source code metrics;Software quality;Software design;Companies;Software maintenance;Software tools;Software measurement;Current measurement;Quality assessment;Programming;Internet},
	Pages = {399-408},
	Title = {Bad smells - humans as code critics},
	Year = {2004},
	Bdsk-Url-1 = {https://doi.org/10.1109/ICSM.2004.1357825}}

@article{Mantyla:2006,
	Abstract = {This paper presents the results of an empirical study on the subjective evaluation of code smells that identify poorly evolvable structures in software. We propose use of the term software evolvability to describe the ease of further developing a piece of software and outline the research area based on four different viewpoints. Furthermore, we describe the differences between human evaluations and automatic program analysis based on software evolvability metrics. The empirical component is based on a case study in a Finnish software product company, in which we studied two topics. First, we looked at the effect of the evaluator when subjectively evaluating the existence of smells in code modules. We found that the use of smells for code evaluation purposes can be difficult due to conflicting perceptions of different evaluators. However, the demographics of the evaluators partly explain the variation. Second, we applied selected source code metrics for identifying four smells and compared these results to the subjective evaluations. The metrics based on automatic program analysis and the human-based smell evaluations did not fully correlate. Based upon our results, we suggest that organizations should make decisions regarding software evolvability improvement based on a combination of subjective evaluations and code metrics. Due to the limitations of the study we also recognize the need for conducting more refined studies and experiments in the area of software evolvability.},
	Author = {M{\"a}ntyl{\"a}, Mika V. and Lassenius, Casper},
	Date-Added = {2019-05-07 00:30:43 +0100},
	Date-Modified = {2020-10-22 13:57:45 +0100},
	Doi = {10.1007/s10664-006-9002-8},
	Issn = {1573-7616},
	Journal = {Empirical Software Engineering},
	Keywords = {Code smells; Subjective evaluation; Perceived evaluation; Maintainability; Evolvability; Code metrics; Software metrics; Human factors},
	Number = {3},
	Pages = {395--431},
	Publisher = {Springer Nature},
	Title = {Subjective evaluation of software evolvability using code smells: An empirical study},
	Url = {http://dx.doi.org/10.1007/s10664-006-9002-8},
	Volume = {11},
	Year = {2006},
	Bdsk-Url-1 = {http://dx.doi.org/10.1007/s10664-006-9002-8}}

@article{Li:2007,
	Abstract = {Bad smells are used as a means to identify problematic classes in object-oriented systems for refactoring. The belief that the bad smells are linked with problematic classes is largely based on previous metric research results. Although there is a plethora of empirical studies linking software metrics to errors and error proneness of classes in object-oriented systems, the link between the bad smells and class error probability in the evolution of object-oriented systems after the systems are released has not been explored. There has been no empirical evidence linking the bad smells with class error probability so far. This paper presents the results from an empirical study that investigated the relationship between the bad smells and class error probability in three error-severity levels in an industrial-strength open source system. Our research, which was conducted in the context of the post-release system evolution process, showed that some bad smells were positively associated with the class error probability in the three error-severity levels. This finding supports the use of bad smells as a systematic method to identify and refactor problematic classes in this specific context.},
	Author = {Wei Li and Raed Shatnawi},
	Date-Added = {2019-05-07 00:30:05 +0100},
	Date-Modified = {2019-08-31 18:09:44 +0100},
	Doi = {10.1016/j.jss.2006.10.018},
	Issn = {0164-1212},
	Journal = {Journal of Systems and Software},
	Keywords = {Object-oriented design, Bad smells, Software metrics, Design evolution, Open source software, Empirical study},
	Note = {Dynamic Resource Management in Distributed Real-Time Systems},
	Number = {7},
	Pages = {1120 - 1128},
	Title = {An empirical study of the bad smells and class error probability in the post-release object-oriented system evolution},
	Url = {http://www.sciencedirect.com/science/article/pii/S0164121206002780},
	Volume = {80},
	Year = {2007},
	Bdsk-Url-1 = {http://www.sciencedirect.com/science/article/pii/S0164121206002780},
	Bdsk-Url-2 = {https://doi.org/10.1016/j.jss.2006.10.018}}

@article{Vaucher:2009,
	Abstract = {"God class" is a term used to describe a certain type of large classes which "know too much or do too much". Often a God class (GC) is created by accident as functionalities are incrementally added to a central class over the course of its evolution. GCs are generally thought to be examples of bad code that should be detected and removed to ensure software quality. However, in some cases, a GC is created by design as the best solution to a particular problem because, for example, the problem is not easily decomposable or strong requirements on efficiency exist. In this paper, we study in two open-source systems the "life cycle" of GCs: how they arise, how prevalent they are, and whether they remain or they are removed as the systems evolve over time, through a number of versions. We show how to detect the degree of "godliness" of classes automatically. Then, we show that by identifying the evolution of "godliness", we can distinguish between those classes that are so by design (good code) from those that occurred by accident (bad code). This methodology can guide software quality teams in their efforts to implement prevention and correction mechanisms.},
	Author = {Vaucher, Stephane and Khomh, Foutse and Moha, Naouel and Gueheneuc, Yann-Gael},
	Date-Added = {2019-05-07 00:29:37 +0100},
	Date-Modified = {2020-10-24 20:23:15 +0100},
	Doi = {10.1109/wcre.2009.23},
	Isbn = {9780769538679},
	Journal = {2009 16th Working Conference on Reverse Engineering},
	Keywords = {Design smells; antipatterns; software evolution; empirical study},
	Pages = {145-154},
	Publisher = {IEEE},
	Title = {Tracking Design Smells: Lessons from a Study of God Classes},
	Url = {http://dx.doi.org/10.1109/WCRE.2009.23},
	Year = {2009},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/WCRE.2009.23},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/wcre.2009.23}}

@article{Khomh:2009,
	Abstract = {Code smells are poor implementation choices, thought to make object-oriented systems hard to maintain. In this study, we investigate if classes with code smells are more change-prone than classes without smells. Specifically, we test the general hypothesis: classes with code smells are not more change prone than other classes. We detect 29 code smells in 9 releases of Azureus and in 13 releases of Eclipse, and study the relation between classes with these code smells and class change-proneness. We show that, in almost all releases of Azureus and Eclipse, classes with code smells are more change-prone than others, and that specific smells are more correlated than others to change-proneness. These results justify a posteriori previous work on the specification and detection of code smells and could help focusing quality assurance and testing activities.},
	Author = {Khomh, Foutse and Di Penta, Massimiliano and Gueheneuc, Yann-Gael},
	Date-Added = {2019-05-07 00:28:49 +0100},
	Date-Modified = {2020-10-24 20:22:39 +0100},
	Doi = {10.1109/wcre.2009.28},
	Isbn = {9780769538679},
	Journal = {2009 16th Working Conference on Reverse Engineering},
	Keywords = {Code Smells; Mining Software Repositories; Empirical Software Engineering},
	Pages = {75-84},
	Publisher = {IEEE},
	Title = {An Exploratory Study of the Impact of Code Smells on Software Change-proneness},
	Url = {http://dx.doi.org/10.1109/WCRE.2009.28},
	Year = {2009},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/WCRE.2009.28},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/wcre.2009.28}}

@article{DAmbros:2010,
	Abstract = {The presence of design flaws in a software system has a negative impact on the quality of the software, as they indicate violations of design practices and principles, which make a software system harder to understand, maintain, and evolve. Software defects are tangible effects of poor software quality. In this paper we study the relationship between software defects and a number of design flaws. We found that, while some design flaws are more frequent, none of them can be considered more harmful with respect to software defects. We also analyzed the correlation between the introduction of new flaws and the generation of defects.},
	Author = {D'Ambros, Marco and Bacchelli, Alberto and Lanza, Michele},
	Date-Added = {2019-05-07 00:28:12 +0100},
	Date-Modified = {2020-10-24 20:24:49 +0100},
	Doi = {10.1109/qsic.2010.58},
	Isbn = {9781424480784},
	Journal = {2010 10th International Conference on Quality Software},
	Keywords = {Software quality and design; Software defects},
	Pages = {23-31},
	Publisher = {IEEE},
	Title = {On the Impact of Design Flaws on Software Defects},
	Url = {http://dx.doi.org/10.1109/QSIC.2010.58},
	Year = {2010},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/QSIC.2010.58},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/qsic.2010.58}}

@article{Chatzigeorgiou:2010,
	Abstract = {Software design problems are known and perceived under many different terms such as bad smells, flaws, non-compliance to design principles, violation of heuristics, excessive metric values and antipatterns, signifying the importance of handling them in the construction and maintenance of software. Once a design problem is identified, it can be removed by applying an appropriate refactoring, improving in most cases several aspects of quality such as maintainability, comprehensibility and reusability. This paper, taking advantage of recent advances and tools in the identification of non-trivial bad smells, explores the presence and evolution of such problems by analyzing past versions of code. Several interesting questions can be investigated such as whether the number of problems increases with the passage of software generations, whether problems vanish by time or only by targeted human intervention, whether bad smells occur in the course of evolution of a module or exist right from the beginning and whether refactorings targeting at smell removal are frequent. In contrast to previous studies that investigate the application of refactorings in the history of a software project, we attempt to study the subject from the point of view of the problems themselves distinguishing deliberate maintenance activities from the removal of design problems as a side effect of software evolution. Results are discussed for two open-source systems and three bad smells.},
	Author = {Chatzigeorgiou, Alexander and Manakos, Anastasios},
	Date-Added = {2019-05-07 00:27:23 +0100},
	Date-Modified = {2020-10-24 20:24:31 +0100},
	Doi = {10.1109/quatic.2010.16},
	Isbn = {9781424485390},
	Journal = {2010 Seventh International Conference on the Quality of Information and Communications Technology},
	Keywords = {bad smell; refactoring; software repositories; software history; evolution},
	Pages = {106-115},
	Publisher = {IEEE},
	Title = {Investigating the Evolution of Bad Smells in Object-Oriented Code},
	Url = {http://dx.doi.org/10.1109/QUATIC.2010.16},
	Year = {2010},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/QUATIC.2010.16},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/quatic.2010.16}}

@article{Carneiro:2010,
	Abstract = {Code smells are anomalies often caused by the way concerns are realized in the source code. Their identification might depend on properties governing the structure of individual concerns and their inter-dependencies in the system implementation. Although code visualization tools are increasingly applied to support anomaly detection, they are mostly limited to represent modular structures, such as methods, classes and packages. This paper presents a multiple views approach that enriches four categories of code views with concern properties, namely: (i) concern's package-class method structure, (ii) concern's inheritance-wise structure, (iii)concern dependency, and (iv) concern dependency weight. An exploratory study was conducted to assess the extent to which visual views support code smell detection. Developers identified a set of well-known code smells on five versions of an open source system. Two important results came out of this study. First, the concern-driven views provided useful support to identify God Class and Divergent Change smells. Second, strategies for smell detection supported by the multiple concern views were uncovered.},
	Author = {Carneiro, Glauco de F. and Silva, Marcos and Mara, Leandra and Figueiredo, Eduardo and Sant'Anna, Claudio and Garcia, Alessandro and Mendonca, Manoel},
	Date-Added = {2019-05-07 00:26:42 +0100},
	Date-Modified = {2020-10-24 20:24:11 +0100},
	Doi = {10.1109/sbes.2010.21},
	Isbn = {9781424489176},
	Journal = {2010 Brazilian Symposium on Software Engineering},
	Keywords = {software visualization; code smells; concerns; program comprehension},
	Pages = {128-137},
	Publisher = {IEEE},
	Title = {Identifying Code Smells with Multiple Concern Views},
	Url = {http://dx.doi.org/10.1109/SBES.2010.21},
	Year = {2010},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/SBES.2010.21},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/sbes.2010.21}}

@article{Olbrich:2010,
	Abstract = {Code smells are particular patterns in object-oriented systems that are perceived to lead to difficulties in the maintenance of such systems. It is held that to improve maintainability, code smells should be eliminated by refactoring. It is claimed that classes that are involved in certain code smells are liable to be changed more frequently and have more defects than other classes in the code. We investigated the extent to which this claim is true for God Classes and Brain Classes, with and without normalizing the effects with respect to the class size. We analyzed historical data from 7 to 10 years of the development of three open-source software systems. The results show that God and Brain Classes were changed more frequently and contained more defects than other kinds of class. However, when we normalized the measured effects with respect to size, then God and Brain Classes were less subject to change and had fewer defects than other classes. Hence, under the assumption that God and Brain Classes contain on average as much functionality per line of code as other classes, the presence of God and Brain Classes is not necessarily harmful; in fact, such classes may be an efficient way of organizing code.},
	Author = {Olbrich, Steffen M. and Cruzes, Daniela S. and Sjoberg, Dag I.K.},
	Date-Added = {2019-05-07 00:26:10 +0100},
	Date-Modified = {2020-10-24 20:23:34 +0100},
	Doi = {10.1109/icsm.2010.5609564},
	Isbn = {9781424486304},
	Journal = {2010 IEEE International Conference on Software Maintenance},
	Keywords = {Code smells; detection strategies; change frequency; defects; software evolution; open source},
	Pages = {1-10},
	Publisher = {IEEE},
	Title = {Are all code smells harmful? A study of God Classes and Brain Classes in the evolution of three open source systems},
	Url = {http://dx.doi.org/10.1109/ICSM.2010.5609564},
	Year = {2010},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/ICSM.2010.5609564},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/icsm.2010.5609564}}

@article{Marinescu:2011,
	Abstract = {Design flaws are those characteristics of design entities (e.g., methods, classes) which make them harder to maintain. Existing studies show that classes revealing particular design flaws are more change and defect prone than the other classes. Since various collaborations are found among the instances of classes, classes are not isolated within the source code of object-oriented systems. In this paper we investigate if classes using classes revealing design flaws are more defect prone than classes which do not use classes revealing design flaws. We detect four design flaws in three releases of Eclipse and investigate the relation between classes that use/do not use flawed classes and defects. The results show that classes that use flawed classes are defect prone and this does not depend on the number of the used flawed classes. This findings show a new type of correlation between design flaws and defects, bringing evidence related to an increased likelihood of exhibiting defects for classes that use classes revealing design flaws. Based on the provided evidence, practitioners are advised once again about the negative impact design flaws have at a source code level.},
	Author = {Marinescu, Radu and Marinescu, Cristina},
	Date-Added = {2019-05-07 00:25:08 +0100},
	Date-Modified = {2020-10-24 20:25:25 +0100},
	Doi = {10.1109/scam.2011.9},
	Isbn = {9781457709326},
	Journal = {2011 IEEE 11th International Working Conference on Source Code Analysis and Manipulation},
	Keywords = {source code; defects; design flaws; detection strategies; software repositories; empirical software engineering},
	Pages = {65-74},
	Publisher = {IEEE},
	Title = {Are the Clients of Flawed Classes (Also) Defect Prone?},
	Url = {http://dx.doi.org/10.1109/SCAM.2011.9},
	Year = {2011},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/SCAM.2011.9},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/scam.2011.9}}

@article{Macia:2012,
	Abstract = {As software systems are maintained, their architecture modularity often degrades through architectural erosion and drift. More directly, however, the modularity of software implementations degrades through the introduction of code anomalies, informally known as code smells. A number of strategies have been developed for supporting the automatic identification of implementation anomalies when only the source code is available. However, it is still unknown how reliable these strategies are when revealing code anomalies related to erosion and drift processes. In this paper, we present an exploratory analysis that investigates to what extent the automatically-detected code anomalies are related to problems that occur with an evolving system's architecture. We analyzed code anomaly occurrences in 38 versions of 5 applications using existing detection strategies. The outcome of our evaluation suggests that many of the code anomalies detected by the employed strategies were not related to architectural problems. Even worse, over 50% of the anomalies not observed by the employed techniques (false negatives) were found to be correlated with architectural problems.},
	Author = {Macia, Isela and Garcia, Joshua and Popescu, Daniel and Garcia, Alessandro and Medvidovic, Nenad and von Staa, Arndt},
	Date-Added = {2019-05-07 00:23:28 +0100},
	Date-Modified = {2020-10-24 20:26:21 +0100},
	Doi = {10.1145/2162049.2162069},
	Isbn = {9781450310925},
	Journal = {Proceedings of the 11th annual international conference on Aspect-oriented Software Development - AOSD '12},
	Keywords = {code anomalies; architectural anomalies; architectural degradation symptoms; architectural violations},
	Pages = {167--178},
	Publisher = {ACM Press},
	Title = {Are Automatically-detected Code Anomalies Relevant to Architectural Modularity?: An Exploratory Analysis of Evolving Systems},
	Url = {http://dx.doi.org/10.1145/2162049.2162069},
	Year = {2012},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/2162049.2162069}}

@article{Peters:2012,
	Abstract = {An anti-pattern is a commonly occurring solution to a recurring problem that will typically negatively impact code quality. Code smells are considered to be symptoms of anti-patterns and occur at source code level. The lifespan of code smells in a software system can be determined by mining the software repository on which the system is stored. This provides insight into the behaviour of software developers with regard to resolving code smells and anti-patterns. In a case study, we investigate the lifespan of code smells and the refactoring behaviour of developers in seven open source systems. The results of this study indicate that engineers are aware of code smells, but are not very concerned with their impact, given the low refactoring activity.},
	Author = {Peters, Ralph and Zaidman, Andy},
	Date-Added = {2019-05-07 00:22:34 +0100},
	Date-Modified = {2020-10-24 20:26:57 +0100},
	Doi = {10.1109/csmr.2012.79},
	Isbn = {9781467309844},
	Journal = {2012 16th European Conference on Software Maintenance and Reengineering},
	Pages = {411-416},
	Publisher = {IEEE},
	Title = {Evaluating the Lifespan of Code Smells using Software Repository Mining},
	Url = {http://dx.doi.org/10.1109/CSMR.2012.79},
	Year = {2012},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/CSMR.2012.79},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/csmr.2012.79}}

@article{Macia:2012a,
	Abstract = {The longevity of evolving software systems largely depends on their resilience to architectural design degradation. It is often assumed that code anomalies are always key indicators of architecture degradation symptoms. The problem is that there is still limited knowledge about the circumstances under which code anomalies represent architectural problems. Without this knowledge, developers are not able to implement architecturally-relevant strategies for code refactoring. This paper presents an empirical study about the influence of code anomalies on architecture degradation symptoms. To this end, we studied the relationship between code anomalies and architecture problems in 6 software systems, which were intended to adhere different architectural decompositions. A total of 40 versions and 2056 code anomalies were analyzed. Our study revealed that 78% of all architecture problems in the programs were related to code anomalies. In particular, more than 33% of all architecture problems were unexpectedly induced by anomalous code elements in the systems' first version. We also found that the refactoring strategies, even when frequently applied in those systems, did not significantly contribute to remove architecturally-relevant code anomalies.},
	Author = {Macia, Isela and Arcoverde, Roberta and Garcia, Alessandro and Chavez, Christina and von Staa, Arndt},
	Date-Added = {2019-05-07 00:21:47 +0100},
	Date-Modified = {2020-10-24 20:27:13 +0100},
	Doi = {10.1109/csmr.2012.35},
	Isbn = {9781467309844},
	Journal = {2012 16th European Conference on Software Maintenance and Reengineering},
	Keywords = {code anomaly; refactoring; architectural violation; architectural anomaly},
	Pages = {277-286},
	Publisher = {IEEE},
	Title = {On the Relevance of Code Anomalies for Identifying Architecture Degradation Symptoms},
	Url = {http://dx.doi.org/10.1109/CSMR.2012.35},
	Year = {2012},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/CSMR.2012.35},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/csmr.2012.35}}

@article{Rahman:2011,
	Abstract = {Clones are generally considered bad programming practice in software engineering folklore. They are identified as a bad smell (Fowler et al. 1999) and a major contributor to project maintenance difficulties. Clones inherently cause code bloat, thus increasing project size and maintenance costs. In this work, we try to validate the conventional wisdom empirically to see whether cloning makes code more defect prone. This paper analyses the relationship between cloning and defect proneness. For the four medium to large open source projects that we studied, we find that, first, the great majority of bugs are not significantly associated with clones. Second, we find that clones may be less defect prone than non-cloned code. Third, we find little evidence that clones with more copies are actually more error prone. Fourth, we find little evidence to support the claim that clone groups that span more than one file or directory are more defect prone than collocated clones. Finally, we find that developers do not need to put a disproportionately higher effort to fix clone dense bugs. Our findings do not support the claim that clones are really a ``bad smell'' (Fowler et al. 1999). Perhaps we can clone, and breathe easily, at the same time.},
	Author = {Rahman, Foyzur and Bird, Christian and Devanbu, Premkumar},
	Date-Added = {2019-05-07 00:21:08 +0100},
	Date-Modified = {2020-10-22 14:22:51 +0100},
	Doi = {10.1007/s10664-011-9195-3},
	Issn = {1573-7616},
	Journal = {Empirical Software Engineering},
	Keywords = {Empirical software engineering; Software maintenance; Software clone; Software quality; Software evolution},
	Number = {4-5},
	Pages = {503--530},
	Publisher = {Springer Nature},
	Title = {Clones: what is that smell?},
	Url = {http://dx.doi.org/10.1007/s10664-011-9195-3},
	Volume = {17},
	Year = {2011},
	Bdsk-Url-1 = {http://dx.doi.org/10.1007/s10664-011-9195-3}}

@article{Yamashita:2012,
	Abstract = {Code smells are manifestations of design flaws that can degrade code maintainability. As such, the existence of code smells seems an ideal indicator for maintainability assessments. However, to achieve comprehensive and accurate evaluations based on code smells, we need to know how well they reflect factors affecting maintainability. After identifying which maintainability factors are reflected by code smells and which not, we can use complementary means to assess the factors that are not addressed by smells. This paper reports on an empirical study that investigates the extent to which code smells reflect factors affecting maintainability that have been identified as important by programmers. We consider two sources for our analysis: (1) expert-based maintainability assessments of four Java systems before they entered a maintenance project, and (2) observations and interviews with professional developers who maintained these systems during 14 working days and implemented a number of change requests.},
	Author = {Yamashita, Aiko and Moonen, Leon},
	Date-Added = {2019-05-07 00:20:28 +0100},
	Date-Modified = {2020-10-24 20:26:38 +0100},
	Doi = {10.1109/icsm.2012.6405287},
	Isbn = {9781467323130},
	Journal = {2012 28th IEEE International Conference on Software Maintenance (ICSM)},
	Keywords = {maintainability evaluation; code smells},
	Pages = {306-315},
	Publisher = {IEEE},
	Title = {Do code smells reflect important maintainability aspects?},
	Url = {http://dx.doi.org/10.1109/ICSM.2012.6405287},
	Year = {2012},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/ICSM.2012.6405287},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/icsm.2012.6405287}}

@article{Sjoberg:2013,
	Abstract = {Context: Code smells are assumed to indicate bad design that leads to less maintainable code. However, this assumption has not been investigated in controlled studies with professional software developers. Aim: This paper investigates the relationship between code smells and maintenance effort. Method: Six developers were hired to perform three maintenance tasks each on four functionally equivalent Java systems originally implemented by different companies. Each developer spent three to four weeks. In total, they modified 298 Java files in the four systems. An Eclipse IDE plug-in measured the exact amount of time a developer spent maintaining each file. Regression analysis was used to explain the effort using file properties, including the number of smells. Result: None of the 12 investigated smells was significantly associated with increased effort after we adjusted for file size and the number of changes; Refused Bequest was significantly associated with decreased effort. File size and the number of changes explained almost all of the modeled variation in effort. Conclusion: The effects of the 12 smells on maintenance effort were limited. To reduce maintenance effort, a focus on reducing code size and the work practices that limit the number of changes may be more beneficial than refactoring code smells.},
	Author = {Sjoberg, Dag I.K. and Yamashita, Aiko and Anda, Bente C.D. and Mockus, Audris and Dyba, Tore},
	Date-Added = {2019-05-07 00:19:29 +0100},
	Date-Modified = {2020-10-22 14:11:07 +0100},
	Doi = {10.1109/tse.2012.89},
	Issn = {1939-3520},
	Journal = {IEEE Transactions on Software Engineering},
	Keywords = {Maintainability; object-oriented design; product metrics; code churn},
	Number = {8},
	Pages = {1144--1156},
	Publisher = {Institute of Electrical and Electronics Engineers (IEEE)},
	Title = {Quantifying the Effect of Code Smells on Maintenance Effort},
	Url = {http://dx.doi.org/10.1109/TSE.2012.89},
	Volume = {39},
	Year = {2013},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/TSE.2012.89},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/tse.2012.89}}

@article{Yamashita:2013d,
	Abstract = {Context
Code smells are indicators of poor coding and design choices that can cause problems during software maintenance and evolution.
Objective
This study is aimed at a detailed investigation to which extent problems in maintenance projects can be predicted by the detection of currently known code smells.
Method
A multiple case study was conducted, in which the problems faced by six developers working on four different Java systems were registered on a daily basis, for a period up to four weeks. Where applicable, the files associated to the problems were registered. Code smells were detected in the pre-maintenance version of the systems, using the tools Borland Together and InCode. In-depth examination of quantitative and qualitative data was conducted to determine if the observed problems could be explained by the detected smells.
Results
From the total set of problems, roughly 30% percent were related to files containing code smells. In addition, interaction effects were observed amongst code smells, and between code smells and other code characteristics, and these effects led to severe problems during maintenance. Code smell interactions were observed between collocated smells (i.e., in the same file), and between coupled smells (i.e., spread over multiple files that were coupled).
Conclusions
The role of code smells on the overall system maintainability is relatively minor, thus complementary approaches are needed to achieve more comprehensive assessments of maintainability. Moreover, to improve the explanatory power of code smells, interaction effects amongst collocated smells and coupled smells should be taken into account during analysis.},
	Author = {Aiko Yamashita and Leon Moonen},
	Date-Added = {2019-05-07 00:18:47 +0100},
	Date-Modified = {2019-08-31 18:09:44 +0100},
	Doi = {10.1016/j.infsof.2013.08.002},
	Issn = {0950-5849},
	Journal = {Information and Software Technology},
	Keywords = {Code smells, Maintainability, Empirical study},
	Number = {12},
	Pages = {2223 - 2242},
	Title = {To what extent can maintenance problems be predicted by code smell detection? - An empirical study},
	Url = {http://www.sciencedirect.com/science/article/pii/S0950584913001614},
	Volume = {55},
	Year = {2013},
	Bdsk-Url-1 = {http://www.sciencedirect.com/science/article/pii/S0950584913001614},
	Bdsk-Url-2 = {https://doi.org/10.1016/j.infsof.2013.08.002}}

@article{Yamashita:2013a,
	Abstract = {Context
Code smells are manifestations of design flaws that can degrade code maintainability. So far, no research has investigated if these indicators are useful for conducting system-level maintainability evaluations.
Aim
The research in this paper investigates the potential of code smells to reflect system-level indicators of maintainability.
Method
We evaluated four medium-sized Java systems using code smells and compared the results against previous evaluations on the same systems based on expert judgment and the Chidamber and Kemerer suite of metrics. The systems were maintained over a period of up to 4 weeks. During maintenance, effort (person-hours) and number of defects were measured to validate the different evaluation approaches.
Results
Most code smells are strongly influenced by size; consequently code smells are not good indicators for comparing the maintainability of systems differing greatly in size. Also, from the comparison of the different evaluation approaches, expert judgment was found as the most accurate and flexible since it considered effects due to the system's size and complexity and could adapt to different maintenance scenarios.
Conclusion
Code smell approaches show promise as indicators of the need for maintenance in a way that other purely metric-based approaches lack.},
	Author = {Aiko Yamashita and Steve Counsell},
	Date-Added = {2019-05-07 00:18:08 +0100},
	Date-Modified = {2019-08-31 18:09:44 +0100},
	Doi = {10.1016/j.jss.2013.05.007},
	Issn = {0164-1212},
	Journal = {Journal of Systems and Software},
	Keywords = {Code smells, Maintainability, Empirical study, System evaluation},
	Number = {10},
	Pages = {2639 - 2653},
	Title = {Code smells as system-level indicators of maintainability: An empirical study},
	Url = {http://www.sciencedirect.com/science/article/pii/S0164121213001258},
	Volume = {86},
	Year = {2013},
	Bdsk-Url-1 = {http://www.sciencedirect.com/science/article/pii/S0164121213001258},
	Bdsk-Url-2 = {https://doi.org/10.1016/j.jss.2013.05.007}}

@article{Zazworka:2011,
	Abstract = {Technical debt is a metaphor describing situations where developers accept sacrifices in one dimension of development (e.g. software quality) in order to optimize another dimension (e.g. implementing necessary features before a deadline). Approaches, such as code smell detection, have been developed to identify particular kinds of debt, e.g. design debt. What has not yet been understood is the impact design debt has on the quality of a software product. Answering this question is important for understanding how growing debt affects a software product and how it slows down development, e.g. though introducing rework such as fixing bugs. In this case study we investigate how design debt, in the form of god classes, affects the maintainability and correctness of software products by studying two sample applications of a small-size software development company. The results show that god classes are changed more often and contain more defects than non-god classes. This result complements findings of earlier research and suggests that technical debt has a negative impact on software quality, and should therefore be identified and managed closely in the development process.},
	Author = {Zazworka, Nico and Shaw, Michele A. and Shull, Forrest and Seaman, Carolyn},
	Date-Added = {2019-05-07 00:17:26 +0100},
	Date-Modified = {2020-10-24 20:25:42 +0100},
	Doi = {10.1145/1985362.1985366},
	Isbn = {9781450305860},
	Journal = {Proceeding of the 2nd working on Managing technical debt - MTD '11},
	Keywords = {god class; technical debt; design debt; refactoring; maintainability; code smells},
	Pages = {17--23},
	Publisher = {ACM Press},
	Title = {Investigating the impact of design debt on software quality},
	Url = {http://dx.doi.org/10.1145/1985362.1985366},
	Year = {2011},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/1985362.1985366}}

@article{Yamashita:2013c,
	Abstract = {Code smells are indicators of issues with source code quality that may hinder evolution. While previous studies mainly focused on the effects of individual code smells on maintainability, we conjecture that not only the individual code smells but also the interactions between code smells affect maintenance. We empirically investigate the interactions amongst 12 code smells and analyze how those interactions relate to maintenance problems. Professional developers were hired for a period of four weeks to implement change requests on four medium-sized Java systems with known smells. On a daily basis, we recorded what specific problems they faced and which artifacts were associated with them. Code smells were automatically detected in the pre- maintenance versions of the systems and analyzed using Principal Component Analysis (PCA) to identify patterns of co-located code smells. Analysis of these factors with the observed maintenance problems revealed how smells that were co-located in the same artifact interacted with each other, and affected maintainability. Moreover, we found that code smell interactions occurred across coupled artifacts, with comparable negative effects as same- artifact co-location. We argue that future studies into the effects of code smells on maintainability should integrate dependency analysis in their process so that they can obtain a more complete understanding by including such coupled interactions.},
	Author = {Yamashita, Aiko and Moonen, Leon},
	Date-Added = {2019-05-07 00:16:50 +0100},
	Date-Modified = {2020-10-24 20:28:25 +0100},
	Doi = {10.1109/icse.2013.6606614},
	Isbn = {9781467330732},
	Journal = {2013 35th International Conference on Software Engineering (ICSE)},
	Keywords = {code smells; bad smells; inter-smell relations; smell interaction; software maintenance; software qualit},
	Pages = {682-691},
	Publisher = {IEEE},
	Title = {Exploring the impact of inter-smell relations on software maintainability: An empirical study},
	Url = {http://dx.doi.org/10.1109/ICSE.2013.6606614},
	Year = {2013},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/ICSE.2013.6606614},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/icse.2013.6606614}}

@article{Schumacher:2010,
	Abstract = {Identifying refactoring opportunities in software systems is an important activity in today's agile development environments. The concept of code smells has been proposed to characterize different types of design shortcomings in code. Additionally, metric-based detection algorithms claim to identify the "smelly" components automatically. This paper presents results for an empirical study performed in a commercial environment. The study investigates the way professional software developers detect god class code smells, then compares these results to automatic classification. The results show that, even though the subjects perceive detecting god classes as an easy task, the agreement for the classification is low. Misplaced methods are a strong driver for letting subjects identify god classes as such. Earlier proposed metric-based detection approaches performed well compared to the human classification. These results lead to the conclusion that an automated metric-based pre-selection decreases the effort spent on manual code inspections. Automatic detection accompanied by a manual review increases the overall confidence in the results of metric-based classifiers.},
	Author = {Schumacher, Jan and Zazworka, Nico and Shull, Forrest and Seaman, Carolyn and Shaw, Michele},
	Date-Added = {2019-05-07 00:15:43 +0100},
	Date-Modified = {2020-10-24 20:23:53 +0100},
	Doi = {10.1145/1852786.1852797},
	Isbn = {9781450300391},
	Journal = {Proceedings of the 2010 ACM-IEEE International Symposium on Empirical Software Engineering and Measurement - ESEM '10},
	Keywords = {code inspection; empirical study; maintainability; code smells; god class},
	Pages = {10},
	Publisher = {ACM Press},
	Title = {Building empirical support for automated code smell detection},
	Url = {http://dx.doi.org/10.1145/1852786.1852797},
	Year = {2010},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/1852786.1852797}}

@article{Santos:2013,
	Abstract = {Context: The concept of code smells is widespread in Software Engineering. However, in spite of the many discussions and claims about them, there are few empirical studies to support or contest these ideas. In particular, the study of the human perception of what is a code smell and how to deal with it has been mostly neglected. Objective: To build empirical support to understand the effect of god classes, one of the most known code smells. In particular, this paper focuses on how conceptualization affects identification of god classes, i.e., how different people perceive the god class concept. Method: A controlled experiment that extends and builds upon another empirical study about how humans detect god classes [19]. Our study: i) deepens and details some of the research questions of the previous study, ii) introduces a new research question and, iii) when possible, compares the results of both studies. Result: Our findings show that participants have different personal criteria and preferences in choosing drivers to identify god classes. The agreement between participants is not high, which is in accordance with previous studies. Conclusion: This study contributes to expand the empirical data about the human perception of code smells. It also presents a new way to evaluate effort and distraction in experiments through the use of automatic logging of participant actions.},
	Author = {Santos, Jos{\'e} A. M. and de Mendon{\c c}a, Manoel G. and Silva, Carlos V. A.},
	Date-Added = {2019-05-07 00:15:10 +0100},
	Date-Modified = {2020-10-24 20:27:48 +0100},
	Doi = {10.1145/2460999.2461007},
	Isbn = {9781450318488},
	Journal = {Proceedings of the 17th International Conference on Evaluation and Assessment in Software Engineering - EASE '13},
	Keywords = {controlled experiment; code smell; god class},
	Pages = {48--59},
	Publisher = {ACM Press},
	Title = {An exploratory study to investigate the impact of conceptualization in god class detection},
	Url = {http://dx.doi.org/10.1145/2460999.2461007},
	Year = {2013},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/2460999.2461007}}

@article{Olbrich:2009,
	Abstract = {Code smells are design flaws in object-oriented designs that may lead to maintainability issues in the further evolution of the software system. This study focuses on the evolution of code smells within a system and their impact on the change behavior (change frequency and size). The study investigates two code smells, God Class and Shotgun Surgery, by analyzing the historical data over several years of development of two large scale open source systems. The detection of code smells in the evolution of those systems was performed by the application of an automated approach using detection strategies. The results show that we can identify different phases in the evolution of code smells during the system development and that code smell infected components exhibit a different change behavior. This information is useful for the identification of risk areas within a software system that need refactoring to assure a future positive evolution.},
	Author = {Olbrich, Steffen and Cruzes, Daniela S. and Basili, Victor and Zazworka, Nico},
	Date-Added = {2019-05-07 00:14:33 +0100},
	Date-Modified = {2020-10-24 20:22:58 +0100},
	Doi = {10.1109/esem.2009.5314231},
	Isbn = {9781424448425},
	Journal = {2009 3rd International Symposium on Empirical Software Engineering and Measurement},
	Pages = {390-400},
	Publisher = {IEEE},
	Title = {The evolution and impact of code smells: A case study of two open source systems},
	Url = {http://dx.doi.org/10.1109/ESEM.2009.5314231},
	Year = {2009},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/ESEM.2009.5314231},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/esem.2009.5314231}}
