{"managed process": {"desc": "", "sup_topics": ["manager models"], "sub_topics": []}, "collaboration diagrams": {"desc": "Used to show the interactions that occur among a group of objects, where the emphasis is on the objects, their links, and the messages they exchange on these links.", "sup_topics": ["object-oriented design", "behavioral descriptions"], "sub_topics": ["object-class", "collaborative association relationship", "collaborative message"]}, "broadcast models": {"desc": "In these models, an event is, in principle, broadcast to all sub-systems. Any sub-system that has been programmed to handle that event can respond to it.", "sup_topics": ["event-based control"], "sub_topics": ["event-messagehandler", "broadcastsubsystem"]}, "reputation value": {"desc": "", "sup_topics": ["reputation"], "sub_topics": []}, "software engineering project": {"desc": "", "sup_topics": [], "sub_topics": ["testing team", "analysis team", "design team", "implementation team"]}, "boundary-value analysis": {"desc": "Test cases are chosen on and near the boundaries of the input domain of variables, with the underlying rationale that many faults tend to concentrate near the extreme values of inputs.", "sup_topics": ["specification-based techniques"], "sub_topics": []}, "data structure centred design": {"desc": "Data-structure-centered design starts from the data structures a program manipulates rather than from the function it performs.", "sup_topics": ["software design strategies and methods"], "sub_topics": ["flowcharts", "jackson structure diagrams", "formal specification language", "decision tables and diagram"]}, "server": {"desc": "", "sup_topics": ["client-server models"], "sub_topics": []}, "testing objective": {"desc": "Testing is conducted in view of a specific objective, which is stated more or less explicitly, and with varying degrees of precision. Stating the objective in precise, quantitative terms allows control to be established over the test process.", "sup_topics": ["software testing"], "sub_topics": ["test-driven development", "acceptance testing", "conformance testing", "configuration testing", "alpha-beta testing", "recovery testing", "stress testing", "reliability achievement and evaluation", "usablity testing", "back-to-back testing", "installation testing", "performance testing", "regression testing"]}, "deployment diagrams": {"desc": "Used to represent a set of (physical) nodes and their interrelationships, and, thus, to model the physical aspects of a system.", "sup_topics": ["object-oriented design", "structural descriptions"], "sub_topics": ["node", "node relationship"]}, "external entity": {"desc": "", "sup_topics": ["data flow component"], "sub_topics": []}, "stake holders": {"desc": "Much software has proved unsatisfactory because it has stressed the requirements of one group of stakeholders at the expense of those of others. Hence, software is delivered which is difficult to use or which subverts the cultural or political structures of the customer organization. The software engineer needs to identify, represent, and manage the viewpoints of many different types of stakeholders.", "sup_topics": ["requirements sources"], "sub_topics": []}, "start transition": {"desc": "", "sup_topics": ["transition-state"], "sub_topics": []}, "safety requirements": {"desc": "", "sup_topics": ["non-functional requirements"], "sub_topics": []}, "special relationship": {"desc": "", "sup_topics": ["flowchart relationship"], "sub_topics": ["stop relationship", "start relationship"]}, "object relationship": {"desc": "", "sup_topics": ["object diagrams"], "sub_topics": ["object generalisation", "object dependency", "object structural"]}, "requirements specification document": {"desc": "A software requirements definition document", "sup_topics": ["requirements specification"], "sub_topics": []}, "timeline": {"desc": "", "sup_topics": ["object behaviour models", "sequence diagrams"], "sub_topics": []}, "editors": {"desc": "These tools are used for the creation and modification of programs, and possibly the documents associated with them. They can be generalpurpose text or document editors, or they can be specialized for a target language.", "sup_topics": ["software construction tools"], "sub_topics": []}, "stop transition": {"desc": "", "sup_topics": ["transition-state"], "sub_topics": []}, "repository subsystem": {"desc": "", "sup_topics": ["repository models"], "sub_topics": []}, "flowgraph": {"desc": "A flowgraph is a directed graph the nodes and arcs of which correspond to program elements.", "sup_topics": ["code-based techniques"], "sub_topics": []}, "interface description languages": {"desc": "Programming like languages used to define the interfaces (names and types of exported operations) of software components.", "sup_topics": ["component-based design", "structural descriptions"], "sub_topics": []}, "usage-based techniques": {"desc": "", "sup_topics": ["test techniques"], "sub_topics": ["software reliability engineered testing", "operational profile"]}, "distribution process": {"desc": "", "sup_topics": ["multiprocessor architectures"], "sub_topics": []}, "users": {"desc": "This group comprises those who will operate the software.", "sup_topics": ["people"], "sub_topics": []}, "object diagrams": {"desc": "Used to represent a set ofobjects and their interrelationships.", "sup_topics": ["object-oriented design", "structural descriptions"], "sub_topics": ["object relationship", "object", "object attribute"]}, "software engineer-based techniques": {"desc": "", "sup_topics": ["test techniques"], "sub_topics": ["adhoc testing", "exploratory testing"]}, "use-cases": {"desc": "Use-cases are a scenario-based technique for requirements elicitation.", "sup_topics": ["elicitation techniques"], "sub_topics": []}, "entity-relationship diagrams": {"desc": "Used to represent conceptual models of data stored in information systems.", "sup_topics": ["structural descriptions", "function-oriented design"], "sub_topics": ["entity attribute", "entity relationship", "entity", "entity attribute value"]}, "class association": {"desc": "", "sup_topics": ["object-oriented decomposition", "class structural"], "sub_topics": []}, "conceptual modeling": {"desc": "Conceptual models comprise models of entities from the problem domain configured to reflect their real-world relationships and dependencies.", "sup_topics": ["requirements analysis"], "sub_topics": ["data-flow models", "classification models", "entity-relation-attribute models", "architectural models", "aggregation models", "stimulus-response models", "object behaviour models"]}, "processor": {"desc": "", "sup_topics": ["multiprocessor architectures"], "sub_topics": []}, "processing step": {"desc": "", "sup_topics": ["flowchart component"], "sub_topics": []}, "testing-related terminology": {"desc": "Definitions of testing and related terminology.", "sup_topics": ["software testing"], "sub_topics": ["failure", "fault"]}, "usability requirements": {"desc": "A usability requirement specifies how easy the system must be to use.", "sup_topics": ["non-functional requirements"], "sub_topics": []}, "use case relationship": {"desc": "", "sup_topics": ["use case diagrams"], "sub_topics": ["include use case relationship", "generalisation use case relationship", "extend use case relationship", "association use case relationship"]}, "programming language": {"desc": "ProgrammingLanguage contains the least amount of information about specific application areas and development processes, and so require the most training and skill to use effectively.", "sup_topics": ["construction languages"], "sub_topics": ["linguistic", "formal", "visual"]}, "join transition": {"desc": "", "sup_topics": ["concurrent transition"], "sub_topics": []}, "state": {"desc": "", "sup_topics": ["stimulus-response models", "statechart diagrams"], "sub_topics": []}, "repository": {"desc": "Central database that can be accessed by all subsystems.", "sup_topics": ["repository models"], "sub_topics": []}, "include use case relationship": {"desc": "", "sup_topics": ["use case relationship"], "sub_topics": []}, "client": {"desc": "", "sup_topics": ["client-server models"], "sub_topics": []}, "class diagrams": {"desc": "Used to represent a set of classes and their interrelationships.", "sup_topics": ["object-oriented design", "design team", "structural descriptions"], "sub_topics": ["class operation", "class relationship", "class", "class attribute"]}, "service registry": {"desc": "", "sup_topics": ["service-oriented system architecture"], "sub_topics": []}, "performance requirements": {"desc": "How fast the system must execute.", "sup_topics": ["non-functional requirements"], "sub_topics": []}, "defect identification": {"desc": "In testing for defect identification, a successful test is one which causes the system to fail.", "sup_topics": ["testing issues"], "sub_topics": []}, "equivalence partitioning": {"desc": "The input domain is subdivided into a collection of subsets, or equivalent classes, which are deemed equivalent according to a specified relation, and a representative set of tests (sometimes only one) is taken from each class.", "sup_topics": ["specification-based techniques"], "sub_topics": []}, "flowchart component relationship": {"desc": "", "sup_topics": ["flowchart relationship"], "sub_topics": []}, "interrupt-driven models": {"desc": "These are exclusively used in real-time systems where external interrupts are detected by an interrupt handler. They are then passed to some other component for processing.", "sup_topics": ["event-based control"], "sub_topics": ["handler", "interrupt", "event process"]}, "distributed object architectures": {"desc": "", "sup_topics": ["distributed systems architectures"], "sub_topics": ["domain-specific services", "object request broker", "large-grain objects"]}, "decision rule": {"desc": "", "sup_topics": ["decision tables and diagram"], "sub_topics": []}, "object-class": {"desc": "", "sup_topics": ["collaboration diagrams"], "sub_topics": []}, "class composition": {"desc": "", "sup_topics": ["class structural"], "sub_topics": []}, "organisational environment": {"desc": "Software is often required to support a business process, the selection of which may be conditioned by the structure, culture, and internal politics of the organization. The software engineer needs to be sensitive to these, since, in general, new software should not force unplanned change on the business process.", "sup_topics": ["requirements sources"], "sub_topics": []}, "testability": {"desc": "The term \u201csoftware testability\u201d has two related but different meanings: on the one hand, it refers to the degree to which it is easy for software to fulfill a given test coverage criterion; on the other hand, it is defined as the likelihood, possibly measured statistically, that the software will expose a failure under testing, if it is faulty. Both meanings are important.", "sup_topics": ["testing issues"], "sub_topics": []}, "start transition ": {"desc": "", "sup_topics": ["special transition"], "sub_topics": []}, "manager models": {"desc": "This is applicable to concurrent systems. One system component is designated as a system manager and controls the starting, stopping and coordination of other system processes. A process is a sub-system or module that can execute in parallel with other processes. A form of this model may also be applied in sequential systems where a management routine calls particular sub-systems depending on the values of some state variables. This is usually implemented as a case statement.", "sup_topics": ["centralised control"], "sub_topics": ["managed process", "central controller"]}, "node dependency": {"desc": "", "sup_topics": ["node relationship"], "sub_topics": []}, "language-processing systems": {"desc": "Language-processing systems accept a natural or aritificial language as an input and generate some other representation of that language as an output.", "sup_topics": ["application architectures"], "sub_topics": ["repository models", "data flow diagrams"]}, "distributed server": {"desc": "", "sup_topics": ["distributed client-server architectures"], "sub_topics": []}, "testing team": {"desc": "", "sup_topics": ["software engineering project"], "sub_topics": []}, "operational environment": {"desc": "Requirements will be derived from the environment in which the software will be executed. These may be, for example, timing constraints in real-time software or interoperability constraints in an office environment. These must be actively sought out, because they can greatly affect software feasibility and cost, and restrict design choices.", "sup_topics": ["requirements sources"], "sub_topics": []}, "object aggregation": {"desc": "", "sup_topics": ["object structural"], "sub_topics": []}, "implementation requirements": {"desc": "Implementation requirements such as the programming language or design method used", "sup_topics": ["non-functional requirements"], "sub_topics": []}, "service requestor": {"desc": "", "sup_topics": ["service-oriented system architecture"], "sub_topics": []}, "construction languages": {"desc": "Construction Languages include all forms of communication by which a human can specify an executable problem solution to a computer.", "sup_topics": ["software construction"], "sub_topics": ["programming language", "configuration language", "toolkit language"]}, "non-functional requirements": {"desc": "Nonfunctional requirements are the ones that act to constrain the solution.", "sup_topics": ["requirements"], "sub_topics": ["safety requirements", "usability requirements", "performance requirements", "implementation requirements", "delivery requirements", "privacy requirements", "portability requirements", "reliability requirements", "interoperability requirements", "ethical requirements", "space requirements", "standards requirements"]}, "single entity attribute value": {"desc": "", "sup_topics": ["entity attribute value"], "sub_topics": []}, "test techniques": {"desc": "One of the aims of testing is to reveal as much potential for failure as possible, and many techniques have been developed to do this, which attempt to \u201cbreak\u201d the program, by running one or more tests drawn from identified classes of executions deemed equivalent. The leading principle underlying such techniques is to be as systematic as possible in identifying a representative set of program behaviors; for instance, considering subclasses of the input domain, scenarios, states, and dataflow.", "sup_topics": ["software testing"], "sub_topics": ["usage-based techniques", "software engineer-based techniques", "specification-based techniques", "code-based techniques", "application nature-based techniques", "fault-based techniques"]}, "object": {"desc": "", "sup_topics": ["object diagrams"], "sub_topics": []}, "object attribute": {"desc": "", "sup_topics": ["object diagrams"], "sub_topics": []}, "entity attribute": {"desc": "A property of an entity or a relationship", "sup_topics": ["entity-relationship diagrams", "entity-relation-attribute models"], "sub_topics": ["simple entity attribute", "composite entity attribute"]}, "coding": {"desc": "", "sup_topics": ["software construction"], "sub_topics": ["source code organisation", "code documentation", "code-level security breaches prevention", "use of control structures", "understandable source code techniques", "code tuning", "handling of error conditions", "resource usages"]}, "integration": {"desc": "A key activity during construction is the integration of separately constructed routines, classes, components, and subsystems. In addition, a particular software system may need to be integrated with other software or hardware systems.", "sup_topics": ["software construction"], "sub_topics": []}, "node": {"desc": "", "sup_topics": ["deployment diagrams"], "sub_topics": []}, "object association": {"desc": "", "sup_topics": ["object structural"], "sub_topics": []}, "stop relationship": {"desc": "", "sup_topics": ["special relationship"], "sub_topics": []}, "simple entity attribute": {"desc": "", "sup_topics": ["entity attribute"], "sub_topics": []}, "data-flow models": {"desc": "Data-flow models show how data is processed by a system.", "sup_topics": ["conceptual modeling"], "sub_topics": ["data flow component relationship", "data flow component"]}, "stop transition ": {"desc": "", "sup_topics": ["special transition"], "sub_topics": []}, "specification-based techniques": {"desc": "", "sup_topics": ["test techniques"], "sub_topics": ["boundary-value analysis", "equivalence partitioning", "decision table", "robustness testing", "formal specifications testing", "finite-state machine-based", "random testing"]}, "logical condition relationship": {"desc": "", "sup_topics": ["flowchart relationship"], "sub_topics": []}, "software design strategies and methods": {"desc": "There exist various general strategies to help guide the design process. In contrast with general strategies, methods are more specific in that they generally suggest and provide a set of notations to be used with the method, a description of the process to be used when following the method and a set of guidelines in using the method. [Bud04:c8] Such methods are useful as a means of transferring knowledge and as a common framework for teams of software engineers.", "sup_topics": ["software design"], "sub_topics": ["data structure centred design", "object-oriented design", "component-based design", "function-oriented design"]}, "test-driven development": {"desc": "Test-driven development is not a test technique per se, promoting the use of tests as a surrogate for a requirements specification document rather than as an independent check that the software has correctly implemented the requirements.", "sup_topics": ["testing objective"], "sub_topics": []}, "generalisation use case relationship": {"desc": "", "sup_topics": ["use case relationship"], "sub_topics": []}, "fork transition": {"desc": "", "sup_topics": ["concurrent transition"], "sub_topics": []}, "crc class": {"desc": "A class represents a collection of similar objects.", "sup_topics": ["class responsibility collaborator cards"], "sub_topics": []}, "source code organisation": {"desc": "Source code organization (into statements, routines, classes, packages, or other structures)", "sup_topics": ["coding"], "sub_topics": []}, "acceptance testing": {"desc": "Acceptance testing checks the system behavior against the customer\u2019s requirements.", "sup_topics": ["testing objective"], "sub_topics": []}, "distributed network": {"desc": "", "sup_topics": ["distributed client-server architectures"], "sub_topics": []}, "process requirements": {"desc": "A process parameter is essentially a constraint on the development of the software.", "sup_topics": ["requirements"], "sub_topics": []}, "dataflow-based criteria": {"desc": "In data-flow-based testing, the control flowgraph is annotated with information about how the program variables are defined, used, and killed (undefined).", "sup_topics": ["code-based techniques"], "sub_topics": []}, "program design languages": {"desc": "Structured-programming-like languages used to describe, generally at the detailed design stage, the behavior of a procedure or method.", "sup_topics": ["object-oriented design", "component-based design", "behavioral descriptions", "function-oriented design"], "sub_topics": []}, "requirements specification": {"desc": "The basis for agreement between customers and contractors or suppliers on what the software product is to do, as well as what it is not expected to do.", "sup_topics": ["software requirements"], "sub_topics": ["requirements specification document"]}, "unit testing": {"desc": "Unit testing verifies the functioning in isolation of software pieces which are separately testable. Depending on the context, these could be the individual subprograms or a larger component made of tightly related units.", "sup_topics": ["test levels"], "sub_topics": []}, "activity": {"desc": "", "sup_topics": ["activity diagrams"], "sub_topics": []}, "systems organisation": {"desc": "The organisation of a system reflects the basic strategy that is used to structure a system. The system organisation may be directly reflected in the sub-system structure. However, it is often the case that the sub-system model includes more detail than the organisational model and there is not always a simple mapping from sub-systems to organisational structure.", "sup_topics": ["architectural design"], "sub_topics": ["client-server models", "repository models", "layered models"]}, "condition message": {"desc": "", "sup_topics": ["collaborative message"], "sub_topics": []}, "call-return models": {"desc": "This is the familiar top-down subroutine model where control starts at the top of a subroutine hierarchy and, through subroutine calls, passes to lower levels in the tree. The subroutine model is only applicable to sequential systems.", "sup_topics": ["centralised control"], "sub_topics": ["routine"]}, "object-oriented decomposition": {"desc": "Object-oriented decomposition where you decompose a system into a set of communicating objects.", "sup_topics": ["modular decomposition styles"], "sub_topics": ["class association", "class operation", "class", "class attribute"]}, "error guessing": {"desc": "In error guessing, test cases are specifically designed by software engineers trying to figure out the most plausible faults in a given program. A good source of information is the history of faults discovered in earlier projects, as well as the software engineer\u2019s expertise.", "sup_topics": ["fault-based techniques"], "sub_topics": []}, "entity relationship": {"desc": "A set of meaningful associations among entities.", "sup_topics": ["entity-relationship diagrams", "entity-relation-attribute models"], "sub_topics": ["complex entity relationship", "binary entity relationship", "unary entity relationship"]}, "corba": {"desc": "", "sup_topics": ["object request broker"], "sub_topics": []}, "flowcharts": {"desc": "Used to represent the flow of control and the associated actions to be performed.", "sup_topics": ["data structure centred design", "behavioral descriptions"], "sub_topics": ["flowchart component", "flowchart relationship"]}, "delivery requirements": {"desc": "Delivery requirements specify when the product and its documentation are to be delivered.", "sup_topics": ["non-functional requirements"], "sub_topics": []}, "handler": {"desc": "", "sup_topics": ["interrupt-driven models", "event-processing systems"], "sub_topics": []}, "jackson structure diagrams": {"desc": "Used to describe the data structures in terms of sequence, selection, and iteration.", "sup_topics": ["data structure centred design", "structural descriptions"], "sub_topics": ["jackson entity", "jackson action"]}, "software design notations": {"desc": "It is to represent software design artifacts.", "sup_topics": ["software design"], "sub_topics": ["structural descriptions", "behavioral descriptions"]}, "linguistic": {"desc": "Linguistic notations are distinguished in particular by the use of word-like strings of text to represent complex software constructions, and the combination of such word like strings into patterns that have a sentence-like syntax.", "sup_topics": ["programming language"], "sub_topics": []}, "object composition": {"desc": "", "sup_topics": ["object structural"], "sub_topics": []}, "activity diagrams": {"desc": "Used to show the control flow from activity (\u201congoing non-atomic execution within a state machine\u201d) to activity.", "sup_topics": ["object-oriented design", "design team", "behavioral descriptions"], "sub_topics": ["activity", "transition-activity", "swimlane"]}, "defect tracking": {"desc": "Failures observed during testing are most often due to faults or defects in the software. Such defects can be analyzed to determine when they were introduced into the software.", "sup_topics": ["test activities"], "sub_topics": []}, "code documentation": {"desc": "", "sup_topics": ["coding"], "sub_topics": []}, "goals": {"desc": "It refers to the overall, high-level objectives of the software. Software engineers need to pay particular attention to assessing the value (relative to priority) and cost of goals.", "sup_topics": ["requirements sources"], "sub_topics": []}, "class operation": {"desc": "", "sup_topics": ["class diagrams", "object-oriented decomposition", "classification models", "aggregation models"], "sub_topics": []}, "component": {"desc": "", "sup_topics": ["component diagrams"], "sub_topics": []}, "multiprocessor architectures": {"desc": "", "sup_topics": ["distributed systems architectures"], "sub_topics": ["distribution process", "processor"]}, "test execution frameworks": {"desc": "", "sup_topics": ["software testing tools"], "sub_topics": []}, "object-oriented design": {"desc": "Inheritance and polymorphism play a key role to the field of component-based design, where meta-information can be defined and accessed (through reflection, for example).", "sup_topics": ["software design strategies and methods"], "sub_topics": ["collaboration diagrams", "deployment diagrams", "object diagrams", "class diagrams", "program design languages", "activity diagrams", "use case diagrams", "class responsibility collaborator cards", "statechart diagrams", "sequence diagrams"]}, "entity": {"desc": "A set of objects with the same properties which are identified by a user or organisation as having an independent existence.", "sup_topics": ["entity-relationship diagrams", "entity-relation-attribute models"], "sub_topics": []}, "component relationship": {"desc": "", "sup_topics": ["component diagrams"], "sub_topics": ["component dependency", "component structural", "component generalisation"]}, "gui testing": {"desc": "", "sup_topics": ["application nature-based techniques"], "sub_topics": []}, "failure": {"desc": "An undesired effect observed in the system\u2019s delivered service. Testing can reveal failures, but it is the faults that can and must be removed.", "sup_topics": ["testing-related terminology"], "sub_topics": []}, "interactor viewpoints": {"desc": "Interactor viewpoints represent people or other systems that interact directly with the system.", "sup_topics": ["viewpoints"], "sub_topics": []}, "software reliability engineered testing": {"desc": "Software Reliability Engineered Testing (SRET) is a testing method encompassing the whole development process, whereby testing is \u201cdesigned and guided by reliability objectives and expected relative usage and criticality of different functions in the field.\u201d", "sup_topics": ["usage-based techniques"], "sub_topics": []}, "privacy requirements": {"desc": "", "sup_topics": ["non-functional requirements"], "sub_topics": []}, "component composition": {"desc": "", "sup_topics": ["component structural"], "sub_topics": []}, "actor": {"desc": "", "sup_topics": ["use case diagrams"], "sub_topics": []}, "ethnography": {"desc": "Ethnography is an observational technique that can be used to understand social and organisational requirements.", "sup_topics": ["elicitation techniques"], "sub_topics": []}, "function-oriented pipelining": {"desc": "Function-oriented pipelining where you decompose a system into functional modules that accept input data and transform it into output data.", "sup_topics": ["modular decomposition styles"], "sub_topics": ["data flow component relationship", "data flow component"]}, "infeasible paths": {"desc": "Infeasible paths, the control flow paths that cannot be exercised by any input data.", "sup_topics": ["testing issues"], "sub_topics": []}, "distributed systems architectures": {"desc": "", "sup_topics": ["software architecture"], "sub_topics": ["distributed object architectures", "multiprocessor architectures", "inter-organisational distributed computing", "distributed client-server architectures"]}, "software testing": {"desc": "An activity performed for evaluating product quality, and for improving it, by identifying defects and problems.", "sup_topics": ["software engineering domain"], "sub_topics": ["testing objective", "testing-related terminology", "test techniques", "testing issues", "test levels", "test activities"]}, "classification models": {"desc": "Classification models show how entities have common characteristic.", "sup_topics": ["conceptual modeling"], "sub_topics": ["class operation", "class generalisation", "class", "class attribute"]}, "test-case generation": {"desc": "Generation of test cases is based on the level of testing to be performed and the particular testing techniques. Test cases should be under the control of software configuration management and include the expected results for each test.", "sup_topics": ["test activities"], "sub_topics": ["test-case"]}, "entity-relation-attribute models": {"desc": "Entity-Relation-Attribute models show the data entities, their associated attributes and the relations between these entities.", "sup_topics": ["conceptual modeling"], "sub_topics": ["entity attribute", "entity relationship", "entity", "entity attribute value"]}, "class relationship": {"desc": "", "sup_topics": ["class diagrams"], "sub_topics": ["class generalisation", "class dependency", "class structural"]}, "beta-test": {"desc": "Beta-test versions of software products.", "sup_topics": ["prototypes"], "sub_topics": []}, "mechanical agent": {"desc": "", "sup_topics": ["oracle"], "sub_topics": []}, "formal": {"desc": "Formal notations rely less on intuitive, everyday meanings of words and text strings and more on definitions backed up by precise, unambiguous, and formal (or mathematical) definitions.", "sup_topics": ["programming language"], "sub_topics": []}, "test selection criteria": {"desc": "A test selection criterion is a means of deciding what a suitable set of test cases should be.", "sup_topics": ["test criteria"], "sub_topics": []}, "test evaluation tools": {"desc": "", "sup_topics": ["software testing tools"], "sub_topics": []}, "domain-specific services": {"desc": "", "sup_topics": ["distributed object architectures"], "sub_topics": []}, "indirect viewpoints": {"desc": "Indirect viewpoints represent stakeholders who do not use the system themselves but who influence the requirements in some way.", "sup_topics": ["viewpoints"], "sub_topics": []}, "decision table": {"desc": "Decision tables represent logical relationships between conditions (roughly, inputs) and actions (roughly, outputs). Test cases are systematically derived by considering every possible combination of conditions and actions.", "sup_topics": ["specification-based techniques"], "sub_topics": []}, "conformance testing": {"desc": "Conformance testing is aimed at validating whether or not the observed behavior of the tested software conforms to its specifications.", "sup_topics": ["testing objective"], "sub_topics": []}, "emergent properties": {"desc": "Some requirements represent emergent properties of software\u2014that is, requirements which cannot be addressed by a single component, but which depend for their satisfaction on how all the software components interoperate.", "sup_topics": ["requirements"], "sub_topics": []}, "configuration testing": {"desc": "In cases where software is built to serve different user, configuration testing analyzes the software under the various specified configurations.", "sup_topics": ["testing objective"], "sub_topics": []}, "test management tools": {"desc": "", "sup_topics": ["software testing tools"], "sub_topics": []}, "architectural design": {"desc": "Architecturel design process from a decision perspective rather than from an activity perspective.", "sup_topics": ["software architecture"], "sub_topics": ["systems organisation", "modular decomposition styles", "control styles"]}, "reuse": {"desc": "Implementing software reuse entails more than creating and using libraries of assets. It requires formalizing the practice of reuse by integrating reuse processes and activities into the software life cycle.", "sup_topics": ["software construction"], "sub_topics": ["reusable units"]}, "requirements analysis": {"desc": "The process of analyzing requirements.", "sup_topics": ["software requirements"], "sub_topics": ["conceptual modeling", "requirements negotiation"]}, "class generalisation": {"desc": "", "sup_topics": ["classification models", "class relationship"], "sub_topics": []}, "code-based techniques": {"desc": "", "sup_topics": ["test techniques"], "sub_topics": ["flowgraph", "dataflow-based criteria", "control-flow-based criteria"]}, "use case": {"desc": "", "sup_topics": ["use case diagrams"], "sub_topics": []}, "peer to peer architecture": {"desc": "Peer-to-peer systems are decentralised systems where computations may be carried out by any node on the network and in principle at least no distinctions are made between clients and servers.", "sup_topics": ["inter-organisational distributed computing"], "sub_topics": ["peer"]}, "class": {"desc": "", "sup_topics": ["class diagrams", "object-oriented decomposition", "classification models", "aggregation models"], "sub_topics": []}, "ternary entity relationship": {"desc": "A relationship of degree three.", "sup_topics": ["complex entity relationship"], "sub_topics": []}, "extend use case relationship": {"desc": "", "sup_topics": ["use case relationship"], "sub_topics": []}, "mutation testing": {"desc": "A mutant is a slightly modified version of the program under test, differing from it by a small, syntactic change. Every test case exercises both the original and all generated mutants: if a test case is successful in identifying the difference between the program and a mutant, the latter is said to be \u201ckilled\u201d.", "sup_topics": ["fault-based techniques"], "sub_topics": []}, "start relationship": {"desc": "", "sup_topics": ["special relationship"], "sub_topics": []}, "centralised control": {"desc": "One sub-system has overall responsibility for control and starts and stops other sub-systems. It may also devolve control to another sub-system but will expect to have this control responsibility returned to it.", "sup_topics": ["control styles"], "sub_topics": ["manager models", "call-return models"]}, "open interviews": {"desc": "Open interviews where there is no predefined agenda. The requirements engineering team explores a range of issues with system stakeholders and hence develops a better understanding of their needs.", "sup_topics": ["interviews"], "sub_topics": []}, "service": {"desc": "", "sup_topics": ["service-oriented system architecture"], "sub_topics": []}, "requirements sources": {"desc": "It is designed to promote awareness of the various sources of software requirements and of the frameworks for managing them.", "sup_topics": ["requirements elicitation"], "sub_topics": ["stake holders", "organisational environment", "operational environment", "goals", "domain knowledge"]}, "data store ": {"desc": "", "sup_topics": ["flowchart component"], "sub_topics": []}, "software tools": {"desc": "Software development tools are the computer-based tools that are intended to assist the software life cycle processes.", "sup_topics": ["software engineering domain"], "sub_topics": ["software design tools", "software requirements tools", "software testing tools", "software construction tools"]}, "alpha-beta testing": {"desc": "Before the software is released, it is sometimes given to a small, representative set of potential users for trial use, either in-house (alpha testing) or external (beta testing). These users report problems with the product. Alpha and beta use is often uncontrolled, and is not always referred to in a test plan.", "sup_topics": ["testing objective"], "sub_topics": []}, "regulators": {"desc": "Many application domains such as banking and public transport are regulated.", "sup_topics": ["people"], "sub_topics": []}, "software design tools": {"desc": "Tools for creating and checking software designs.", "sup_topics": ["software tools"], "sub_topics": []}, "recovery testing": {"desc": "Recovery testing is aimed at verifying software restart capabilities after a \u201cdisaster.\u201d", "sup_topics": ["testing objective"], "sub_topics": []}, "test planning": {"desc": "Key aspects of test planning include coordination of personnel, management of available test facilities and equipment (which may include magnetic media, test plans and procedures), and planning for possible undesirable outcomes. If more than one baseline of the software is being maintained, then a major planning consideration is the time and effort needed to ensure that the test environment is set to the proper configuration.", "sup_topics": ["test activities"], "sub_topics": []}, "routine": {"desc": "", "sup_topics": ["call-return models"], "sub_topics": []}, "complex entity relationship": {"desc": "A relationship of degree higher than binary.", "sup_topics": ["entity relationship"], "sub_topics": ["ternary entity relationship", "quaternary entity relationship"]}, "node relationship": {"desc": "", "sup_topics": ["deployment diagrams"], "sub_topics": ["node dependency", "node association"]}, "component aggregation": {"desc": "", "sup_topics": ["component structural"], "sub_topics": []}, "entity attribute value": {"desc": "", "sup_topics": ["entity-relationship diagrams", "entity-relation-attribute models"], "sub_topics": ["single entity attribute value", "multi-value entity attribute value"]}, "collaborative association relationship": {"desc": "", "sup_topics": ["collaboration diagrams"], "sub_topics": []}, "component association": {"desc": "", "sup_topics": ["component structural"], "sub_topics": []}, "object-oriented testing": {"desc": "", "sup_topics": ["application nature-based techniques"], "sub_topics": []}, "configuration language": {"desc": "The simplest type of construction language is a configuration language, in which software engineers choose from a limited set of predefined options to create new or custom software installations.", "sup_topics": ["construction languages"], "sub_topics": []}, "architectural models": {"desc": "Architectural models show the principal subsystems that make up a system.", "sup_topics": ["conceptual modeling"], "sub_topics": ["subsystem"]}, "component dependency": {"desc": "", "sup_topics": ["component relationship"], "sub_topics": []}, "control-flow-based criteria": {"desc": "Control-flow-based coverage criteria is aimed at covering all the statements or blocks of statements in a program, or specified combinations of them.", "sup_topics": ["code-based techniques"], "sub_topics": []}, "interpreters": {"desc": "These tools provide software execution through emulation.", "sup_topics": ["software construction tools"], "sub_topics": []}, "loop message": {"desc": "", "sup_topics": ["collaborative message"], "sub_topics": []}, "analysis team": {"desc": "", "sup_topics": ["software engineering project"], "sub_topics": []}, "software engineers": {"desc": "These individuals have a legitimate interest in profiting from developing the software by, for example, reusing components in other products.", "sup_topics": ["people"], "sub_topics": []}, "object request broker": {"desc": "", "sup_topics": ["distributed object architectures"], "sub_topics": ["corba", "com"]}, "code-level security breaches prevention": {"desc": "Prevention of code-level security breaches (buffer overruns or array index overflows, for example)", "sup_topics": ["coding"], "sub_topics": []}, "class dependency": {"desc": "", "sup_topics": ["class relationship"], "sub_topics": []}, "testing issues": {"desc": "", "sup_topics": ["software testing"], "sub_topics": ["defect identification", "testability", "infeasible paths", "test criteria", "limitations of testing", "oracle", "testing effectiveness"]}, "system requirements": {"desc": "System requirements are the requirements for the system as a whole. In a system containing software components, software requirements are derived from system requirements.", "sup_topics": ["requirements"], "sub_topics": []}, "test generator tools": {"desc": "", "sup_topics": ["software testing tools"], "sub_topics": []}, "client-server models": {"desc": "The client\u2013server architectural model is a system model where the system is organised as a set of services and associated servers and clients that access and use the services.", "sup_topics": ["systems organisation"], "sub_topics": ["server", "client", "network"]}, "stress testing": {"desc": "Stress testing exercises software at the maximum design load, as well as beyond it.", "sup_topics": ["testing objective"], "sub_topics": []}, "jackson entity": {"desc": "An entity is an object that acts and is acted on by the system. The root of the parent-child tree is a single entity (the only one on the diagram).", "sup_topics": ["jackson structure diagrams"], "sub_topics": []}, "functional requirements": {"desc": "Functional requirements describe the functions that the software is to execute. They are sometimes known as capabilities.", "sup_topics": ["requirements"], "sub_topics": []}, "requirements modeling tools": {"desc": "These tools are used for eliciting, analyzing, specifying, and validating software requirements.", "sup_topics": ["software requirements tools"], "sub_topics": []}, "inter-organisational distributed computing": {"desc": "For reasons of security and inter-operability, distributed computing has been primarily implemented at the organisational level.", "sup_topics": ["distributed systems architectures"], "sub_topics": ["peer to peer architecture", "service-oriented system architecture"]}, "data flow component relationship": {"desc": "", "sup_topics": ["data-flow models", "function-oriented pipelining", "data-processing systems", "data flow diagrams", "transaction-processing systems"], "sub_topics": []}, "modular decomposition styles": {"desc": "Decomposing sub-systems into modules.", "sup_topics": ["architectural design"], "sub_topics": ["object-oriented decomposition", "function-oriented pipelining"]}, "closed interviews": {"desc": "Closed interviews where the stakeholder answers a predefined set of questions.", "sup_topics": ["interviews"], "sub_topics": []}, "com": {"desc": "", "sup_topics": ["object request broker"], "sub_topics": []}, "design team": {"desc": "", "sup_topics": ["software engineering project"], "sub_topics": ["class diagrams", "activity diagrams", "use case diagrams"]}, "binary entity relationship": {"desc": "A relationship of degree two.", "sup_topics": ["entity relationship"], "sub_topics": []}, "data store": {"desc": "", "sup_topics": ["data flow component"], "sub_topics": []}, "data-processing systems": {"desc": "Data-processing Systems are batch-processing systems where data is input and output in batches from a file or database rather than input from and output to a user terminal.", "sup_topics": ["application architectures"], "sub_topics": ["data flow component relationship", "data flow component"]}, "interrupt": {"desc": "", "sup_topics": ["interrupt-driven models", "event-processing systems"], "sub_topics": []}, "web-based testing": {"desc": "", "sup_topics": ["application nature-based techniques"], "sub_topics": []}, "data process": {"desc": "", "sup_topics": ["data flow component"], "sub_topics": []}, "repository models": {"desc": "All shared data is held in a central database that can be accessed by all sub-systems. Each sub-system maintains its own database. Data is interchanged with other sub-systems by passing messages to them.", "sup_topics": ["language-processing systems", "systems organisation"], "sub_topics": ["repository subsystem", "repository", "interacted component"]}, "safety-critical systems testing": {"desc": "", "sup_topics": ["application nature-based techniques"], "sub_topics": []}, "visual": {"desc": "Visual notations rely much less on the text-oriented notations of both linguistic and formal construction, and instead rely on direct visual interpretation and placement of visual entities that represent the underlying software.", "sup_topics": ["programming language"], "sub_topics": []}, "compilers": {"desc": "Preprocessors, linker/loaders, and code generators.", "sup_topics": ["software construction tools"], "sub_topics": []}, "software requirements tools": {"desc": "Tools for dealing with software requirements.", "sup_topics": ["software tools"], "sub_topics": ["requirements modeling tools", "requirement traceability tools."]}, "component-based design": {"desc": "A software component is an independent unit, having welldefined interfaces and dependencies that can be composed and deployed independently. Component-based design addresses issues related to providing, developing, and integrating such components in order to improve reuse.", "sup_topics": ["software design strategies and methods"], "sub_topics": ["interface description languages", "program design languages", "component diagrams"]}, "software architecture": {"desc": "A software architecture is \u201ca description of the subsystems and components of a software system and the relationships between them.\u201d", "sup_topics": ["software design"], "sub_topics": ["distributed systems architectures", "architectural design", "application architectures"]}, "aggregation models": {"desc": "Aggregation models show how entities in the system are composed of other entities.", "sup_topics": ["conceptual modeling"], "sub_topics": ["class operation", "class", "class aggregation", "class attribute"]}, "data input": {"desc": "", "sup_topics": ["flowchart component"], "sub_topics": []}, "object generalisation": {"desc": "", "sup_topics": ["object relationship"], "sub_topics": []}, "structural descriptions": {"desc": "It is mostly (but not always) graphical, describe and represent the structural aspects of a software design\u2014that is, it describes the major components and how they are interconnected (static view).", "sup_topics": ["software design notations"], "sub_topics": ["deployment diagrams", "interface description languages", "object diagrams", "entity-relationship diagrams", "class diagrams", "jackson structure diagrams", "use case diagrams", "class responsibility collaborator cards", "component diagrams"]}, "robustness testing": {"desc": "An extension of boundary-value analysis technique where in test cases are also chosen outside the input domain of variables, to test program robustness to unexpected or erroneous inputs.", "sup_topics": ["specification-based techniques"], "sub_topics": []}, "formal specifications testing": {"desc": "Giving the specifications in a formal language allows for automatic derivation of functional test cases, and, at the same time, provides a reference output, an oracle, for checking test results. Methods exist for deriving test cases from model-based or algebraic specifications.", "sup_topics": ["specification-based techniques"], "sub_topics": []}, "test environment development": {"desc": "The environment used for testing should be compatible with the software engineering tools. It should facilitate development and control of test cases, as well as logging and recovery of expected results, scripts, and other testing materials.", "sup_topics": ["test activities"], "sub_topics": []}, "formal specification language": {"desc": "Textual languages that use basic notions from mathematics (for example, logic, set, sequence) to rigorously and abstractly define software component interfaces and behavior, often in terms of pre- and post-conditions.", "sup_topics": ["data structure centred design", "behavioral descriptions"], "sub_topics": []}, "software design": {"desc": "The process of defining the architecture, components, interfaces, and other characteristics of a system or component and the result of that process.", "sup_topics": ["software engineering domain"], "sub_topics": ["software design strategies and methods", "software design notations", "software architecture"]}, "data flow diagrams": {"desc": "Used to show data flow among a set of processes.", "sup_topics": ["language-processing systems", "behavioral descriptions", "function-oriented design"], "sub_topics": ["data flow component relationship", "data flow component"]}, "product requirements": {"desc": "Product parameters are requirements on software to be developed.", "sup_topics": ["requirements"], "sub_topics": []}, "domain knowledge": {"desc": "The software engineer needs to acquire, or have available, knowledge about the application domain. This enables them to infer tacit knowledge that the stakeholders do not articulate, assess the trade-offs that will be necessary between conflicting requirements, and, sometimes, to act as a \u201cuser\u201d champion.", "sup_topics": ["requirements sources"], "sub_topics": []}, "distributed client": {"desc": "", "sup_topics": ["distributed client-server architectures"], "sub_topics": []}, "node association": {"desc": "", "sup_topics": ["node relationship"], "sub_topics": []}, "test levels": {"desc": "Software testing is usually performed at different levels along the development and maintenance processes. That is to say, the target of the test can vary: a single module, a group of such modules (related by purpose, use, behavior, or structure), or a whole system.", "sup_topics": ["software testing"], "sub_topics": ["unit testing", "system testing", "integration testing"]}, "toolkit language": {"desc": "Toolkit languages are used to build applications out of toolkits (integrated sets of application-specific reusable parts), and are more complex than configuration languages.", "sup_topics": ["construction languages"], "sub_topics": []}, "event-messagehandler": {"desc": "", "sup_topics": ["broadcast models"], "sub_topics": []}, "adhoc testing": {"desc": "Tests are derived relying on the software engineer\u2019s skill, intuition, and experience with similar programs. Ad hoc testing might be useful for identifying special tests, those not easily captured by formalized techniques.", "sup_topics": ["software engineer-based techniques"], "sub_topics": []}, "transition-activity": {"desc": "", "sup_topics": ["activity diagrams"], "sub_topics": ["activity transition", "concurrent transition", "special transition", "branch transition"]}, "stimulus-response models": {"desc": "A stimulus-response models show how the system reacts to internal and external events.", "sup_topics": ["conceptual modeling"], "sub_topics": ["state", "transition-state"]}, "decision tables and diagram": {"desc": "Used to represent complex combinations of conditions and actions.", "sup_topics": ["data structure centred design", "behavioral descriptions"], "sub_topics": ["decision rule", "decision condition", "decision action"]}, "elicitation techniques": {"desc": "This concentrates on techniques for getting human stakeholders to articulate their requirements.", "sup_topics": ["requirements elicitation"], "sub_topics": ["use-cases", "ethnography", "interviews", "viewpoints", "facilitated meeting", "prototypes", "scenarios"]}, "system testing": {"desc": "System testing is concerned with the behavior of a whole system.", "sup_topics": ["test levels"], "sub_topics": []}, "software testing tools": {"desc": "", "sup_topics": ["software tools"], "sub_topics": ["test execution frameworks", "test evaluation tools", "test management tools", "test generator tools", "performance analysis tools"]}, "activity transition": {"desc": "", "sup_topics": ["transition-activity"], "sub_topics": []}, "software engineering domain": {"desc": "", "sup_topics": [], "sub_topics": ["software testing", "software tools", "software design", "software construction", "software requirements"]}, "service-oriented system architecture": {"desc": "", "sup_topics": ["inter-organisational distributed computing"], "sub_topics": ["service registry", "service requestor", "service", "service provider"]}, "test-case": {"desc": "", "sup_topics": ["test-case generation"], "sub_topics": []}, "concurrent programs testing": {"desc": "", "sup_topics": ["application nature-based techniques"], "sub_topics": []}, "concurrent transition": {"desc": "", "sup_topics": ["transition-activity"], "sub_topics": ["join transition", "fork transition"]}, "software construction": {"desc": "The detailed creation of working, meaningful software.", "sup_topics": ["software engineering domain"], "sub_topics": ["construction languages", "coding", "integration", "reuse", "construction testing"]}, "use case diagrams": {"desc": "A description of a functionality that the system provides.", "sup_topics": ["object-oriented design", "design team", "structural descriptions"], "sub_topics": ["use case relationship", "actor", "use case"]}, "people": {"desc": "People who participate in the software engineering process.", "sup_topics": [], "sub_topics": ["users", "regulators", "software engineers", "market analysts", "customers"]}, "debuggers": {"desc": "These tools are considered a separate category since they support the software construction process, but they are different from program editors and compilers.", "sup_topics": ["software construction tools"], "sub_topics": []}, "operational profile": {"desc": "In testing for reliability evaluation, the test environment must reproduce the operational environment of the software as closely as possible. The idea is to infer, from the observed test results, the future reliability of the software when in actual use. To do this, inputs are assigned a probability distribution, or profile, according to their occurrence in actual operation.", "sup_topics": ["usage-based techniques"], "sub_topics": []}, "implementation team": {"desc": "", "sup_topics": ["software engineering project"], "sub_topics": []}, "flowchart component": {"desc": "", "sup_topics": ["flowcharts"], "sub_topics": ["processing step", "data store ", "data input", "data output"]}, "class aggregation": {"desc": "", "sup_topics": ["aggregation models", "class structural"], "sub_topics": []}, "swimlane": {"desc": "", "sup_topics": ["activity diagrams"], "sub_topics": []}, "decision condition": {"desc": "", "sup_topics": ["decision tables and diagram"], "sub_topics": []}, "portability requirements": {"desc": "", "sup_topics": ["non-functional requirements"], "sub_topics": []}, "use of control structures": {"desc": "", "sup_topics": ["coding"], "sub_topics": []}, "large-grain objects": {"desc": "", "sup_topics": ["distributed object architectures"], "sub_topics": []}, "reusable units": {"desc": "", "sup_topics": ["reuse"], "sub_topics": []}, "unary entity relationship": {"desc": "A relationship of degree one.", "sup_topics": ["entity relationship"], "sub_topics": []}, "understandable source code techniques": {"desc": "Techniques for creating understandable source code, including naming and source code layout", "sup_topics": ["coding"], "sub_topics": []}, "integration testing": {"desc": "Integration testing is the process of verifying the interaction between software components. Classical", "sup_topics": ["test levels"], "sub_topics": []}, "component structural": {"desc": "", "sup_topics": ["component relationship"], "sub_topics": ["component composition", "component aggregation", "component association"]}, "reliability requirements": {"desc": "Reliability requirements set out the acceptable failure rate", "sup_topics": ["non-functional requirements"], "sub_topics": []}, "layered models": {"desc": "The layered model of an architecture organises a system into layers, each of which provide a set of services. Each layer can be though of as an abstract machine whose machine language is defined by the services provided by the layer. This \u2018language\u2019 is used to implement the next level of abstract machine.", "sup_topics": ["systems organisation"], "sub_topics": []}, "interviews": {"desc": "Formal or informal interviews with system stakeholders are part of most requirements engineering processes.", "sup_topics": ["elicitation techniques"], "sub_topics": ["open interviews", "closed interviews"]}, "requirements elicitation": {"desc": "Requirements elicitation is concerned with where software requirements come from and how the software engineer can collect them.", "sup_topics": ["software requirements"], "sub_topics": ["requirements sources", "elicitation techniques"]}, "reliability achievement and evaluation": {"desc": "In helping to identify faults, testing is a means to improve reliability. By contrast, by randomly generating test cases according to the operational profile, statistical measures of reliability can be derived.", "sup_topics": ["testing objective"], "sub_topics": []}, "test log": {"desc": "", "sup_topics": ["test activities"], "sub_topics": []}, "class responsibility collaborator cards": {"desc": "Used to denote the names of components (class), their responsibilities, and their collaborating components\u2019 names.", "sup_topics": ["object-oriented design", "structural descriptions"], "sub_topics": ["crc class"]}, "usablity testing": {"desc": "This process evaluates how easy it is for end-users to use and learn the software, including user documentation; how effectively the software functions in supporting user tasks; and, finally, its ability to recover from user errors.", "sup_topics": ["testing objective"], "sub_topics": []}, "interoperability requirements": {"desc": "Interoperability requirements define how the system interacts with systems in other organisations", "sup_topics": ["non-functional requirements"], "sub_topics": []}, "test activities": {"desc": "", "sup_topics": ["software testing"], "sub_topics": ["defect tracking", "test-case generation", "test planning", "test environment development", "test log", "test results evaluation", "test execution"]}, "viewpoints": {"desc": "Viewpoint-oriented approaches to requirements engineering organise both the elicitation process and the requirements themselves using viewpoints. A key strength of viewpoint-oriented analysis is that it recognises multiple perspectives and provides a framework for discovering conflicts in the requirements proposed by different stakeholders.", "sup_topics": ["elicitation techniques"], "sub_topics": ["interactor viewpoints", "indirect viewpoints", "domain viewpoints"]}, "ethical requirements": {"desc": "Ethical requirements are requirements placed on a system to ensure that it will be acceptable to its users and the general public", "sup_topics": ["non-functional requirements"], "sub_topics": []}, "code tuning": {"desc": "", "sup_topics": ["coding"], "sub_topics": []}, "distributed client-server architectures": {"desc": "", "sup_topics": ["distributed systems architectures"], "sub_topics": ["distributed server", "distributed network", "distributed client"]}, "data flow component": {"desc": "", "sup_topics": ["data-flow models", "function-oriented pipelining", "data-processing systems", "data flow diagrams", "transaction-processing systems"], "sub_topics": ["external entity", "data store", "data process"]}, "protocol conformance testing": {"desc": "", "sup_topics": ["application nature-based techniques"], "sub_topics": []}, "software construction tools": {"desc": "These tools are used to produce and translate program representation (for instance, source code) which is sufficiently detailed and explicit to enable machine execution.", "sup_topics": ["software tools"], "sub_topics": ["editors", "interpreters", "compilers", "debuggers"]}, "performance analysis tools": {"desc": "", "sup_topics": ["software testing tools"], "sub_topics": []}, "test criteria": {"desc": "A test selection criterion is a means of deciding what a suitable set of test cases should be. A selection criterion can be used for selecting the test cases or for checking whether a selected test suite is adequate\u2014that is, to decide whether the testing can be stopped.", "sup_topics": ["testing issues"], "sub_topics": ["test selection criteria", "test adequacy criteria"]}, "component generalisation": {"desc": "", "sup_topics": ["component relationship"], "sub_topics": []}, "handling of error conditions": {"desc": "Handling of error conditions\u2014both planned errors and exceptions (input of bad data, for example)", "sup_topics": ["coding"], "sub_topics": []}, "facilitated meeting": {"desc": "The purpose of these is to try to achieve a summative effect whereby a group of people can bring more insight into their software requirements than by working individually.", "sup_topics": ["elicitation techniques"], "sub_topics": []}, "prototypes": {"desc": "A valuable tool for clarifying unclear requirements. They can act in a similar way to scenarios by providing users with a context within which they can better understand what information they need to provide.", "sup_topics": ["elicitation techniques"], "sub_topics": ["beta-test", "mock-ups"]}, "back-to-back testing": {"desc": "A single test set is performed on two implemented versions of a software product, and the results are compared.", "sup_topics": ["testing objective"], "sub_topics": []}, "requirements": {"desc": "the needs and constraints placed on a software product that contribute to the solution of some real-world problem.", "sup_topics": ["software requirements"], "sub_topics": ["non-functional requirements", "process requirements", "emergent properties", "system requirements", "functional requirements", "product requirements", "users requirements", "quantifiable requirements"]}, "construction testing": {"desc": "The purpose of construction testing is to reduce the gap between the time at which faults are inserted into the code and the time those faults are detected.", "sup_topics": ["software construction"], "sub_topics": []}, "association use case relationship": {"desc": "", "sup_topics": ["use case relationship"], "sub_topics": []}, "real-time systems testing": {"desc": "", "sup_topics": ["application nature-based techniques"], "sub_topics": []}, "limitations of testing": {"desc": "Testing theory warns against ascribing an unjustified level of confidence to a series of passed tests. Unfortunately, most established results of testing theory are negative ones, in that they state what testing can never achieve as opposed to what it actually achieved. The most famous quotation in this regard is the Dijkstra aphorism that \u201cprogram testing can be used to show the presence of bugs, but never to show their absence.\u201d The obvious reason is that complete testing is not feasible in real software. Because of this, testing must be driven based on risk and can be seen as a risk management strategy.", "sup_topics": ["testing issues"], "sub_topics": []}, "class attribute": {"desc": "", "sup_topics": ["class diagrams", "object-oriented decomposition", "classification models", "aggregation models"], "sub_topics": []}, "component diagrams": {"desc": "Used to represent a set of components (\u201cphysical and replaceable part[s] of a system that [conform] to and [provide] the realization of a set of interfaces\u201d) and their interrelationships.", "sup_topics": ["component-based design", "structural descriptions"], "sub_topics": ["component", "component relationship", "interface"]}, "peer": {"desc": "The nodes in the network.", "sup_topics": ["peer to peer architecture"], "sub_topics": []}, "quaternary entity relationship": {"desc": "A relationship of degree four.", "sup_topics": ["complex entity relationship"], "sub_topics": []}, "requirement traceability tools.": {"desc": "These tools are becoming increasingly important as the complexity of software grows. Since they are also relevant in other life cycle processes, they are presented separately from the requirements modeling tools.", "sup_topics": ["software requirements tools"], "sub_topics": []}, "software requirements": {"desc": "a software requirement is a property which must be exhibited by software developed or adapted to solve a particular problem.", "sup_topics": ["software engineering domain"], "sub_topics": ["requirements specification", "requirements analysis", "requirements elicitation", "requirements"]}, "interacted component": {"desc": "", "sup_topics": ["repository models"], "sub_topics": []}, "object behaviour models": {"desc": "Object behaviour models show how the operations provided by the objects are used.", "sup_topics": ["conceptual modeling"], "sub_topics": ["timeline"]}, "multi-value entity attribute value": {"desc": "", "sup_topics": ["entity attribute value"], "sub_topics": []}, "class structural": {"desc": "", "sup_topics": ["class relationship"], "sub_topics": ["class association", "class composition", "class aggregation"]}, "control styles": {"desc": "Control models at the architectural level are concerned with the control flow between sub-systems.", "sup_topics": ["architectural design"], "sub_topics": ["centralised control", "event-based control"]}, "behavioral descriptions": {"desc": "It is used to describe the dynamic behavior of software and components.", "sup_topics": ["software design notations"], "sub_topics": ["collaboration diagrams", "program design languages", "flowcharts", "activity diagrams", "formal specification language", "data flow diagrams", "decision tables and diagram", "statechart diagrams", "sequence diagrams"]}, "test results evaluation": {"desc": "The results of testing must be evaluated to determine whether or not the test has been successful.", "sup_topics": ["test activities"], "sub_topics": []}, "statechart diagrams": {"desc": "Used to show the control flow from state to state in a state machine.", "sup_topics": ["object-oriented design", "behavioral descriptions"], "sub_topics": ["state", "transition-state"]}, "test adequacy criteria": {"desc": "It is to decide whether the testing can be stopped.", "sup_topics": ["test criteria"], "sub_topics": []}, "installation testing": {"desc": "Usually after completion of software and acceptance testing, the software can be verified upon installation in the target environment.", "sup_topics": ["testing objective"], "sub_topics": []}, "object dependency": {"desc": "", "sup_topics": ["object relationship"], "sub_topics": []}, "object structural": {"desc": "", "sup_topics": ["object relationship"], "sub_topics": ["object aggregation", "object association", "object composition"]}, "event-based control": {"desc": "Rather than control information being embedded in a sub-system, each sub-system can respond to externally generated events. These events might come from other sub-systems or from the environment of the system.", "sup_topics": ["control styles"], "sub_topics": ["broadcast models", "interrupt-driven models"]}, "event-processing systems": {"desc": "Event-processing Systems respond to events in the system's environment or users interface.", "sup_topics": ["application architectures"], "sub_topics": ["handler", "interrupt", "event process"]}, "market analysts": {"desc": "A mass-market product will not have a commissioning customer, so marketing people are often needed to establish what the market needs and to act as proxy customers.", "sup_topics": ["people"], "sub_topics": []}, "service provider": {"desc": "", "sup_topics": ["service-oriented system architecture"], "sub_topics": []}, "finite-state machine-based": {"desc": "By modeling a program as a finite state machine, tests can be selected in order to cover states and transitions on it.", "sup_topics": ["specification-based techniques"], "sub_topics": []}, "space requirements": {"desc": "How much memory the system requires", "sup_topics": ["non-functional requirements"], "sub_topics": []}, "component-based testing": {"desc": "", "sup_topics": ["application nature-based techniques"], "sub_topics": []}, "requirements negotiation": {"desc": "This concerns resolving problems with requirements where conflicts occur between two stakeholders requiring mutually incompatible features, between requirements and resources, or between functional and non-functional requirements, for example.", "sup_topics": ["requirements analysis"], "sub_topics": []}, "standards requirements": {"desc": "Process standards that must be used", "sup_topics": ["non-functional requirements"], "sub_topics": []}, "mock-ups": {"desc": "Paper mock-ups of screen designs.", "sup_topics": ["prototypes"], "sub_topics": []}, "central controller": {"desc": "", "sup_topics": ["manager models"], "sub_topics": []}, "exploratory testing": {"desc": "Exploratory testing is defined as simultaneous learning, test design, and test execution; that is, the tests are not defined in advance in an established test plan, but are dynamically designed, executed, and modified.", "sup_topics": ["software engineer-based techniques"], "sub_topics": []}, "application nature-based techniques": {"desc": "", "sup_topics": ["test techniques"], "sub_topics": ["gui testing", "object-oriented testing", "web-based testing", "safety-critical systems testing", "concurrent programs testing", "protocol conformance testing", "real-time systems testing", "component-based testing"]}, "jackson action": {"desc": "Actions are carried out by entities and actions affect other entities. They are linked to the root entity and each other in a parent-child hierarchy.", "sup_topics": ["jackson structure diagrams"], "sub_topics": []}, "users requirements": {"desc": "User requirements are statements, in a natural language plus diagrams, of what services the system is expected to provide and the constraints under which it must operate.", "sup_topics": ["requirements"], "sub_topics": []}, "special transition": {"desc": "", "sup_topics": ["transition-activity"], "sub_topics": ["start transition ", "stop transition "]}, "flowchart relationship": {"desc": "", "sup_topics": ["flowcharts"], "sub_topics": ["special relationship", "flowchart component relationship", "logical condition relationship"]}, "domain viewpoints": {"desc": "Domain viewpoints represent domain characteristics and constraints that influence the system requirements.", "sup_topics": ["viewpoints"], "sub_topics": []}, "reputation": {"desc": "", "sup_topics": [""], "sub_topics": ["reputation value", "reputation domain"]}, "network": {"desc": "", "sup_topics": ["client-server models"], "sub_topics": []}, "transaction-processing systems": {"desc": "Transaction-processing Systems are designed to process user requests for information from a database or requests to update the database.", "sup_topics": ["application architectures"], "sub_topics": ["data flow component relationship", "data flow component"]}, "resource usages": {"desc": "Resource usage via use of exclusion mechanisms and discipline in accessing serially reusable resources (including threads or database locks)", "sup_topics": ["coding"], "sub_topics": []}, "state transition": {"desc": "", "sup_topics": ["transition-state"], "sub_topics": []}, "broadcastsubsystem": {"desc": "", "sup_topics": ["broadcast models"], "sub_topics": []}, "subsystem": {"desc": "", "sup_topics": ["architectural models"], "sub_topics": []}, "fault-based techniques": {"desc": "", "sup_topics": ["test techniques"], "sub_topics": ["error guessing", "mutation testing"]}, "performance testing": {"desc": "This is specifically aimed at verifying that the software meets the specified performance requirements, for instance, capacity and response time. A specific kind of performance testing is volume testing in which internal program or system limitations are tried.", "sup_topics": ["testing objective"], "sub_topics": []}, "oracle": {"desc": "An oracle is any (human or mechanical) agent which decides whether a program behaved correctly in a given test, and accordingly produces a verdict of \u201cpass\u201d or \u201cfail.\u201d", "sup_topics": ["testing issues"], "sub_topics": ["mechanical agent"]}, "data output": {"desc": "", "sup_topics": ["flowchart component"], "sub_topics": []}, "customers": {"desc": "This group comprises those who have commissioned the software or who represent the software\u2019s target market.", "sup_topics": ["people"], "sub_topics": []}, "sequence diagrams": {"desc": "Used to show the interactions among a group of objects, with emphasis on the timeordering of messages.", "sup_topics": ["object-oriented design", "behavioral descriptions"], "sub_topics": ["timeline"]}, "event process": {"desc": "", "sup_topics": ["interrupt-driven models", "event-processing systems"], "sub_topics": []}, "test execution": {"desc": "Execution of tests should embody a basic principle of scientific experimentation: everything done during testing should be performed and documented clearly enough that another person could replicate the results.", "sup_topics": ["test activities"], "sub_topics": []}, "decision action": {"desc": "", "sup_topics": ["decision tables and diagram"], "sub_topics": []}, "branch transition": {"desc": "", "sup_topics": ["transition-activity"], "sub_topics": []}, "reputation domain": {"desc": "", "sup_topics": ["reputation"], "sub_topics": []}, "application architectures": {"desc": "", "sup_topics": ["software architecture"], "sub_topics": ["language-processing systems", "data-processing systems", "event-processing systems", "transaction-processing systems"]}, "regression testing": {"desc": "regression testing is the selective retesting of a system or component to verify that modifications have not caused unintended effects. In practice, the idea is to show that software which previously passed the tests still does. It as any repetition of tests intended to show that the software\u2019s behavior is unchanged, except insofar as required.", "sup_topics": ["testing objective"], "sub_topics": []}, "interface": {"desc": "", "sup_topics": ["component diagrams"], "sub_topics": []}, "random testing": {"desc": "Tests are generated purely at random. At least the input domain must be known, to be able to pick random points within it.", "sup_topics": ["specification-based techniques"], "sub_topics": []}, "scenarios": {"desc": "A valuable means for providing context to the elicitation of user requirements. They allow the software engineer to provide a framework for questions about user tasks by permitting \u201cwhat if\u201d and \u201chow is this done\u201d questions to be asked.", "sup_topics": ["elicitation techniques"], "sub_topics": []}, "collaborative message": {"desc": "", "sup_topics": ["collaboration diagrams"], "sub_topics": ["condition message", "loop message"]}, "testing effectiveness": {"desc": "Sample selection can be guided by different objectives: it is only in light of the objective pursued that the effectiveness of the test set can be evaluated.", "sup_topics": ["testing issues"], "sub_topics": []}, "quantifiable requirements": {"desc": "Software requirements should be stated as clearly and as unambiguously as possible, and, where appropriate, quantitatively.", "sup_topics": ["requirements"], "sub_topics": []}, "fault": {"desc": "The cause of a malfunction.", "sup_topics": ["testing-related terminology"], "sub_topics": []}, "composite entity attribute": {"desc": "", "sup_topics": ["entity attribute"], "sub_topics": []}, "function-oriented design": {"desc": "Decomposition centers on identifying the major software functions and then elaborating and refining them in a top-down manner.", "sup_topics": ["software design strategies and methods"], "sub_topics": ["entity-relationship diagrams", "program design languages", "data flow diagrams"]}, "transition-state": {"desc": "", "sup_topics": ["stimulus-response models", "statechart diagrams"], "sub_topics": ["start transition", "stop transition", "state transition"]}}